Created by PLY (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> operation
Rule 2     program -> program operation
Rule 3     program -> empty
Rule 4     operation -> assign o_end
Rule 5     operation -> binop end
Rule 6     operation -> func_call end
Rule 7     operation -> if end
Rule 8     operation -> while end
Rule 9     operation -> func end
Rule 10    operation -> value end
Rule 11    operation -> return o_end
Rule 12    operation -> typed_var end
Rule 13    operation -> end
Rule 14    return -> RETURN binop
Rule 15    return -> RETURN
Rule 16    func -> FUNC id PAREN_OPEN typeargs PAREN_CLOSE o_id code_block
Rule 17    if -> IF binop code_block
Rule 18    if -> IF binop code_block ELSE code_block
Rule 19    while -> WHILE binop code_block
Rule 20    code_block -> CURLY_OPEN o_newline program CURLY_CLOSE
Rule 21    func_call -> id PAREN_OPEN params PAREN_CLOSE
Rule 22    func_call -> id PAREN_OPEN PAREN_CLOSE
Rule 23    assign -> id ASSIGN expr
Rule 24    assign -> onetype_args ASSIGN expr
Rule 25    params -> params COMMA o_newline expr
Rule 26    params -> binop
Rule 27    onetype_args -> typed_var
Rule 28    onetype_args -> onetype_args COMMA o_newline id
Rule 29    typeargs -> typeargs COMMA o_newline typed_var
Rule 30    typeargs -> typeargs COMMA o_newline id
Rule 31    typeargs -> typed_var
Rule 32    typed_var -> id id
Rule 33    expr -> binop
Rule 34    expr -> func_call
Rule 35    expr -> new
Rule 36    new -> NEW func_call
Rule 37    binop -> binop LESS binop
Rule 38    binop -> binop GREATER binop
Rule 39    binop -> binop LESS_EQ binop
Rule 40    binop -> binop GREATER_EQ binop
Rule 41    binop -> binop EQUAL binop
Rule 42    binop -> binop NOT_EQUAL binop
Rule 43    binop -> value
Rule 44    binop -> binop PLUS binop
Rule 45    binop -> binop MINUS binop
Rule 46    binop -> binop MUL binop
Rule 47    binop -> binop DIV binop
Rule 48    binop -> PAREN_OPEN binop PAREN_CLOSE
Rule 49    value -> MINUS value
Rule 50    value -> INTEGER
Rule 51    value -> STRING
Rule 52    value -> id
Rule 53    o_id -> id
Rule 54    o_id -> empty
Rule 55    id -> NAME
Rule 56    id -> VALUE
Rule 57    o_newline -> NEWLINE
Rule 58    o_newline -> empty
Rule 59    o_end -> end
Rule 60    o_end -> empty
Rule 61    end -> SEMICOLON
Rule 62    end -> NEWLINE
Rule 63    empty -> <empty>

Terminals, with rules where they appear

ASSIGN               : 23 24
COMMA                : 25 28 29 30
CURLY_CLOSE          : 20
CURLY_OPEN           : 20
DIV                  : 47
ELSE                 : 18
EQUAL                : 41
FUNC                 : 16
GREATER              : 38
GREATER_EQ           : 40
IF                   : 17 18
INTEGER              : 50
LESS                 : 37
LESS_EQ              : 39
MINUS                : 45 49
MUL                  : 46
NAME                 : 55
NEW                  : 36
NEWLINE              : 57 62
NOT_EQUAL            : 42
PAREN_CLOSE          : 16 21 22 48
PAREN_OPEN           : 16 21 22 48
PLUS                 : 44
RETURN               : 14 15
SEMICOLON            : 61
STRING               : 51
VALUE                : 56
WHILE                : 19
error                : 

Nonterminals, with rules where they appear

assign               : 4
binop                : 5 14 17 18 19 26 33 37 37 38 38 39 39 40 40 41 41 42 42 44 44 45 45 46 46 47 47 48
code_block           : 16 17 18 18 19
empty                : 3 54 58 60
end                  : 5 6 7 8 9 10 12 13 59
expr                 : 23 24 25
func                 : 9
func_call            : 6 34 36
id                   : 16 21 22 23 28 30 32 32 52 53
if                   : 7
new                  : 35
o_end                : 4 11
o_id                 : 16
o_newline            : 20 25 28 29 30
onetype_args         : 24 28
operation            : 1 2
params               : 21 25
program              : 2 20 0
return               : 11
typeargs             : 16 29 30
typed_var            : 12 27 29 31
value                : 10 43 49
while                : 8


state 0

    (0) S' -> . program
    (1) program -> . operation
    (2) program -> . program operation
    (3) program -> . empty
    (4) operation -> . assign o_end
    (5) operation -> . binop end
    (6) operation -> . func_call end
    (7) operation -> . if end
    (8) operation -> . while end
    (9) operation -> . func end
    (10) operation -> . value end
    (11) operation -> . return o_end
    (12) operation -> . typed_var end
    (13) operation -> . end
    (63) empty -> .
    (23) assign -> . id ASSIGN expr
    (24) assign -> . onetype_args ASSIGN expr
    (37) binop -> . binop LESS binop
    (38) binop -> . binop GREATER binop
    (39) binop -> . binop LESS_EQ binop
    (40) binop -> . binop GREATER_EQ binop
    (41) binop -> . binop EQUAL binop
    (42) binop -> . binop NOT_EQUAL binop
    (43) binop -> . value
    (44) binop -> . binop PLUS binop
    (45) binop -> . binop MINUS binop
    (46) binop -> . binop MUL binop
    (47) binop -> . binop DIV binop
    (48) binop -> . PAREN_OPEN binop PAREN_CLOSE
    (21) func_call -> . id PAREN_OPEN params PAREN_CLOSE
    (22) func_call -> . id PAREN_OPEN PAREN_CLOSE
    (17) if -> . IF binop code_block
    (18) if -> . IF binop code_block ELSE code_block
    (19) while -> . WHILE binop code_block
    (16) func -> . FUNC id PAREN_OPEN typeargs PAREN_CLOSE o_id code_block
    (49) value -> . MINUS value
    (50) value -> . INTEGER
    (51) value -> . STRING
    (52) value -> . id
    (14) return -> . RETURN binop
    (15) return -> . RETURN
    (32) typed_var -> . id id
    (61) end -> . SEMICOLON
    (62) end -> . NEWLINE
    (55) id -> . NAME
    (56) id -> . VALUE
    (27) onetype_args -> . typed_var
    (28) onetype_args -> . onetype_args COMMA o_newline id

  ! shift/reduce conflict for PAREN_OPEN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for NAME resolved as shift
  ! shift/reduce conflict for VALUE resolved as shift
    $end            reduce using rule 63 (empty -> .)
    PAREN_OPEN      shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FUNC            shift and go to state 20
    MINUS           shift and go to state 16
    INTEGER         shift and go to state 21
    STRING          shift and go to state 22
    RETURN          shift and go to state 23
    SEMICOLON       shift and go to state 24
    NEWLINE         shift and go to state 25
    NAME            shift and go to state 26
    VALUE           shift and go to state 27

  ! PAREN_OPEN      [ reduce using rule 63 (empty -> .) ]
  ! IF              [ reduce using rule 63 (empty -> .) ]
  ! WHILE           [ reduce using rule 63 (empty -> .) ]
  ! FUNC            [ reduce using rule 63 (empty -> .) ]
  ! MINUS           [ reduce using rule 63 (empty -> .) ]
  ! INTEGER         [ reduce using rule 63 (empty -> .) ]
  ! STRING          [ reduce using rule 63 (empty -> .) ]
  ! RETURN          [ reduce using rule 63 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 63 (empty -> .) ]
  ! NEWLINE         [ reduce using rule 63 (empty -> .) ]
  ! NAME            [ reduce using rule 63 (empty -> .) ]
  ! VALUE           [ reduce using rule 63 (empty -> .) ]

    program                        shift and go to state 1
    operation                      shift and go to state 2
    empty                          shift and go to state 3
    assign                         shift and go to state 4
    binop                          shift and go to state 5
    end                            shift and go to state 6
    func_call                      shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    func                           shift and go to state 10
    value                          shift and go to state 11
    return                         shift and go to state 12
    typed_var                      shift and go to state 13
    id                             shift and go to state 14
    onetype_args                   shift and go to state 15

state 1

    (0) S' -> program .
    (2) program -> program . operation
    (4) operation -> . assign o_end
    (5) operation -> . binop end
    (6) operation -> . func_call end
    (7) operation -> . if end
    (8) operation -> . while end
    (9) operation -> . func end
    (10) operation -> . value end
    (11) operation -> . return o_end
    (12) operation -> . typed_var end
    (13) operation -> . end
    (23) assign -> . id ASSIGN expr
    (24) assign -> . onetype_args ASSIGN expr
    (37) binop -> . binop LESS binop
    (38) binop -> . binop GREATER binop
    (39) binop -> . binop LESS_EQ binop
    (40) binop -> . binop GREATER_EQ binop
    (41) binop -> . binop EQUAL binop
    (42) binop -> . binop NOT_EQUAL binop
    (43) binop -> . value
    (44) binop -> . binop PLUS binop
    (45) binop -> . binop MINUS binop
    (46) binop -> . binop MUL binop
    (47) binop -> . binop DIV binop
    (48) binop -> . PAREN_OPEN binop PAREN_CLOSE
    (21) func_call -> . id PAREN_OPEN params PAREN_CLOSE
    (22) func_call -> . id PAREN_OPEN PAREN_CLOSE
    (17) if -> . IF binop code_block
    (18) if -> . IF binop code_block ELSE code_block
    (19) while -> . WHILE binop code_block
    (16) func -> . FUNC id PAREN_OPEN typeargs PAREN_CLOSE o_id code_block
    (49) value -> . MINUS value
    (50) value -> . INTEGER
    (51) value -> . STRING
    (52) value -> . id
    (14) return -> . RETURN binop
    (15) return -> . RETURN
    (32) typed_var -> . id id
    (61) end -> . SEMICOLON
    (62) end -> . NEWLINE
    (55) id -> . NAME
    (56) id -> . VALUE
    (27) onetype_args -> . typed_var
    (28) onetype_args -> . onetype_args COMMA o_newline id

    PAREN_OPEN      shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FUNC            shift and go to state 20
    MINUS           shift and go to state 16
    INTEGER         shift and go to state 21
    STRING          shift and go to state 22
    RETURN          shift and go to state 23
    SEMICOLON       shift and go to state 24
    NEWLINE         shift and go to state 25
    NAME            shift and go to state 26
    VALUE           shift and go to state 27

    operation                      shift and go to state 28
    assign                         shift and go to state 4
    binop                          shift and go to state 5
    end                            shift and go to state 6
    func_call                      shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    func                           shift and go to state 10
    value                          shift and go to state 11
    return                         shift and go to state 12
    typed_var                      shift and go to state 13
    id                             shift and go to state 14
    onetype_args                   shift and go to state 15

state 2

    (1) program -> operation .

    PAREN_OPEN      reduce using rule 1 (program -> operation .)
    IF              reduce using rule 1 (program -> operation .)
    WHILE           reduce using rule 1 (program -> operation .)
    FUNC            reduce using rule 1 (program -> operation .)
    MINUS           reduce using rule 1 (program -> operation .)
    INTEGER         reduce using rule 1 (program -> operation .)
    STRING          reduce using rule 1 (program -> operation .)
    RETURN          reduce using rule 1 (program -> operation .)
    SEMICOLON       reduce using rule 1 (program -> operation .)
    NEWLINE         reduce using rule 1 (program -> operation .)
    NAME            reduce using rule 1 (program -> operation .)
    VALUE           reduce using rule 1 (program -> operation .)
    $end            reduce using rule 1 (program -> operation .)
    CURLY_CLOSE     reduce using rule 1 (program -> operation .)


state 3

    (3) program -> empty .

    PAREN_OPEN      reduce using rule 3 (program -> empty .)
    IF              reduce using rule 3 (program -> empty .)
    WHILE           reduce using rule 3 (program -> empty .)
    FUNC            reduce using rule 3 (program -> empty .)
    MINUS           reduce using rule 3 (program -> empty .)
    INTEGER         reduce using rule 3 (program -> empty .)
    STRING          reduce using rule 3 (program -> empty .)
    RETURN          reduce using rule 3 (program -> empty .)
    SEMICOLON       reduce using rule 3 (program -> empty .)
    NEWLINE         reduce using rule 3 (program -> empty .)
    NAME            reduce using rule 3 (program -> empty .)
    VALUE           reduce using rule 3 (program -> empty .)
    $end            reduce using rule 3 (program -> empty .)
    CURLY_CLOSE     reduce using rule 3 (program -> empty .)


state 4

    (4) operation -> assign . o_end
    (59) o_end -> . end
    (60) o_end -> . empty
    (61) end -> . SEMICOLON
    (62) end -> . NEWLINE
    (63) empty -> .

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for NEWLINE resolved as shift
    SEMICOLON       shift and go to state 24
    NEWLINE         shift and go to state 25
    PAREN_OPEN      reduce using rule 63 (empty -> .)
    IF              reduce using rule 63 (empty -> .)
    WHILE           reduce using rule 63 (empty -> .)
    FUNC            reduce using rule 63 (empty -> .)
    MINUS           reduce using rule 63 (empty -> .)
    INTEGER         reduce using rule 63 (empty -> .)
    STRING          reduce using rule 63 (empty -> .)
    RETURN          reduce using rule 63 (empty -> .)
    NAME            reduce using rule 63 (empty -> .)
    VALUE           reduce using rule 63 (empty -> .)
    $end            reduce using rule 63 (empty -> .)
    CURLY_CLOSE     reduce using rule 63 (empty -> .)

  ! SEMICOLON       [ reduce using rule 63 (empty -> .) ]
  ! NEWLINE         [ reduce using rule 63 (empty -> .) ]

    o_end                          shift and go to state 29
    end                            shift and go to state 30
    empty                          shift and go to state 31

state 5

    (5) operation -> binop . end
    (37) binop -> binop . LESS binop
    (38) binop -> binop . GREATER binop
    (39) binop -> binop . LESS_EQ binop
    (40) binop -> binop . GREATER_EQ binop
    (41) binop -> binop . EQUAL binop
    (42) binop -> binop . NOT_EQUAL binop
    (44) binop -> binop . PLUS binop
    (45) binop -> binop . MINUS binop
    (46) binop -> binop . MUL binop
    (47) binop -> binop . DIV binop
    (61) end -> . SEMICOLON
    (62) end -> . NEWLINE

    LESS            shift and go to state 33
    GREATER         shift and go to state 34
    LESS_EQ         shift and go to state 35
    GREATER_EQ      shift and go to state 36
    EQUAL           shift and go to state 37
    NOT_EQUAL       shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MUL             shift and go to state 41
    DIV             shift and go to state 42
    SEMICOLON       shift and go to state 24
    NEWLINE         shift and go to state 25

    end                            shift and go to state 32

state 6

    (13) operation -> end .

    PAREN_OPEN      reduce using rule 13 (operation -> end .)
    IF              reduce using rule 13 (operation -> end .)
    WHILE           reduce using rule 13 (operation -> end .)
    FUNC            reduce using rule 13 (operation -> end .)
    MINUS           reduce using rule 13 (operation -> end .)
    INTEGER         reduce using rule 13 (operation -> end .)
    STRING          reduce using rule 13 (operation -> end .)
    RETURN          reduce using rule 13 (operation -> end .)
    SEMICOLON       reduce using rule 13 (operation -> end .)
    NEWLINE         reduce using rule 13 (operation -> end .)
    NAME            reduce using rule 13 (operation -> end .)
    VALUE           reduce using rule 13 (operation -> end .)
    $end            reduce using rule 13 (operation -> end .)
    CURLY_CLOSE     reduce using rule 13 (operation -> end .)


state 7

    (6) operation -> func_call . end
    (61) end -> . SEMICOLON
    (62) end -> . NEWLINE

    SEMICOLON       shift and go to state 24
    NEWLINE         shift and go to state 25

    end                            shift and go to state 43

state 8

    (7) operation -> if . end
    (61) end -> . SEMICOLON
    (62) end -> . NEWLINE

    SEMICOLON       shift and go to state 24
    NEWLINE         shift and go to state 25

    end                            shift and go to state 44

state 9

    (8) operation -> while . end
    (61) end -> . SEMICOLON
    (62) end -> . NEWLINE

    SEMICOLON       shift and go to state 24
    NEWLINE         shift and go to state 25

    end                            shift and go to state 45

state 10

    (9) operation -> func . end
    (61) end -> . SEMICOLON
    (62) end -> . NEWLINE

    SEMICOLON       shift and go to state 24
    NEWLINE         shift and go to state 25

    end                            shift and go to state 46

state 11

    (10) operation -> value . end
    (43) binop -> value .
    (61) end -> . SEMICOLON
    (62) end -> . NEWLINE

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for NEWLINE resolved as shift
    LESS            reduce using rule 43 (binop -> value .)
    GREATER         reduce using rule 43 (binop -> value .)
    LESS_EQ         reduce using rule 43 (binop -> value .)
    GREATER_EQ      reduce using rule 43 (binop -> value .)
    EQUAL           reduce using rule 43 (binop -> value .)
    NOT_EQUAL       reduce using rule 43 (binop -> value .)
    PLUS            reduce using rule 43 (binop -> value .)
    MINUS           reduce using rule 43 (binop -> value .)
    MUL             reduce using rule 43 (binop -> value .)
    DIV             reduce using rule 43 (binop -> value .)
    SEMICOLON       shift and go to state 24
    NEWLINE         shift and go to state 25

  ! SEMICOLON       [ reduce using rule 43 (binop -> value .) ]
  ! NEWLINE         [ reduce using rule 43 (binop -> value .) ]

    end                            shift and go to state 47

state 12

    (11) operation -> return . o_end
    (59) o_end -> . end
    (60) o_end -> . empty
    (61) end -> . SEMICOLON
    (62) end -> . NEWLINE
    (63) empty -> .

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for NEWLINE resolved as shift
    SEMICOLON       shift and go to state 24
    NEWLINE         shift and go to state 25
    PAREN_OPEN      reduce using rule 63 (empty -> .)
    IF              reduce using rule 63 (empty -> .)
    WHILE           reduce using rule 63 (empty -> .)
    FUNC            reduce using rule 63 (empty -> .)
    MINUS           reduce using rule 63 (empty -> .)
    INTEGER         reduce using rule 63 (empty -> .)
    STRING          reduce using rule 63 (empty -> .)
    RETURN          reduce using rule 63 (empty -> .)
    NAME            reduce using rule 63 (empty -> .)
    VALUE           reduce using rule 63 (empty -> .)
    $end            reduce using rule 63 (empty -> .)
    CURLY_CLOSE     reduce using rule 63 (empty -> .)

  ! SEMICOLON       [ reduce using rule 63 (empty -> .) ]
  ! NEWLINE         [ reduce using rule 63 (empty -> .) ]

    o_end                          shift and go to state 48
    end                            shift and go to state 30
    empty                          shift and go to state 31

state 13

    (12) operation -> typed_var . end
    (27) onetype_args -> typed_var .
    (61) end -> . SEMICOLON
    (62) end -> . NEWLINE

    ASSIGN          reduce using rule 27 (onetype_args -> typed_var .)
    COMMA           reduce using rule 27 (onetype_args -> typed_var .)
    SEMICOLON       shift and go to state 24
    NEWLINE         shift and go to state 25

    end                            shift and go to state 49

state 14

    (23) assign -> id . ASSIGN expr
    (21) func_call -> id . PAREN_OPEN params PAREN_CLOSE
    (22) func_call -> id . PAREN_OPEN PAREN_CLOSE
    (52) value -> id .
    (32) typed_var -> id . id
    (55) id -> . NAME
    (56) id -> . VALUE

    ASSIGN          shift and go to state 51
    PAREN_OPEN      shift and go to state 52
    SEMICOLON       reduce using rule 52 (value -> id .)
    NEWLINE         reduce using rule 52 (value -> id .)
    LESS            reduce using rule 52 (value -> id .)
    GREATER         reduce using rule 52 (value -> id .)
    LESS_EQ         reduce using rule 52 (value -> id .)
    GREATER_EQ      reduce using rule 52 (value -> id .)
    EQUAL           reduce using rule 52 (value -> id .)
    NOT_EQUAL       reduce using rule 52 (value -> id .)
    PLUS            reduce using rule 52 (value -> id .)
    MINUS           reduce using rule 52 (value -> id .)
    MUL             reduce using rule 52 (value -> id .)
    DIV             reduce using rule 52 (value -> id .)
    NAME            shift and go to state 26
    VALUE           shift and go to state 27

    id                             shift and go to state 50

state 15

    (24) assign -> onetype_args . ASSIGN expr
    (28) onetype_args -> onetype_args . COMMA o_newline id

    ASSIGN          shift and go to state 53
    COMMA           shift and go to state 54


state 16

    (49) value -> MINUS . value
    (49) value -> . MINUS value
    (50) value -> . INTEGER
    (51) value -> . STRING
    (52) value -> . id
    (55) id -> . NAME
    (56) id -> . VALUE

    MINUS           shift and go to state 16
    INTEGER         shift and go to state 21
    STRING          shift and go to state 22
    NAME            shift and go to state 26
    VALUE           shift and go to state 27

    value                          shift and go to state 55
    id                             shift and go to state 56

state 17

    (48) binop -> PAREN_OPEN . binop PAREN_CLOSE
    (37) binop -> . binop LESS binop
    (38) binop -> . binop GREATER binop
    (39) binop -> . binop LESS_EQ binop
    (40) binop -> . binop GREATER_EQ binop
    (41) binop -> . binop EQUAL binop
    (42) binop -> . binop NOT_EQUAL binop
    (43) binop -> . value
    (44) binop -> . binop PLUS binop
    (45) binop -> . binop MINUS binop
    (46) binop -> . binop MUL binop
    (47) binop -> . binop DIV binop
    (48) binop -> . PAREN_OPEN binop PAREN_CLOSE
    (49) value -> . MINUS value
    (50) value -> . INTEGER
    (51) value -> . STRING
    (52) value -> . id
    (55) id -> . NAME
    (56) id -> . VALUE

    PAREN_OPEN      shift and go to state 17
    MINUS           shift and go to state 16
    INTEGER         shift and go to state 21
    STRING          shift and go to state 22
    NAME            shift and go to state 26
    VALUE           shift and go to state 27

    binop                          shift and go to state 57
    value                          shift and go to state 58
    id                             shift and go to state 56

state 18

    (17) if -> IF . binop code_block
    (18) if -> IF . binop code_block ELSE code_block
    (37) binop -> . binop LESS binop
    (38) binop -> . binop GREATER binop
    (39) binop -> . binop LESS_EQ binop
    (40) binop -> . binop GREATER_EQ binop
    (41) binop -> . binop EQUAL binop
    (42) binop -> . binop NOT_EQUAL binop
    (43) binop -> . value
    (44) binop -> . binop PLUS binop
    (45) binop -> . binop MINUS binop
    (46) binop -> . binop MUL binop
    (47) binop -> . binop DIV binop
    (48) binop -> . PAREN_OPEN binop PAREN_CLOSE
    (49) value -> . MINUS value
    (50) value -> . INTEGER
    (51) value -> . STRING
    (52) value -> . id
    (55) id -> . NAME
    (56) id -> . VALUE

    PAREN_OPEN      shift and go to state 17
    MINUS           shift and go to state 16
    INTEGER         shift and go to state 21
    STRING          shift and go to state 22
    NAME            shift and go to state 26
    VALUE           shift and go to state 27

    binop                          shift and go to state 59
    value                          shift and go to state 58
    id                             shift and go to state 56

state 19

    (19) while -> WHILE . binop code_block
    (37) binop -> . binop LESS binop
    (38) binop -> . binop GREATER binop
    (39) binop -> . binop LESS_EQ binop
    (40) binop -> . binop GREATER_EQ binop
    (41) binop -> . binop EQUAL binop
    (42) binop -> . binop NOT_EQUAL binop
    (43) binop -> . value
    (44) binop -> . binop PLUS binop
    (45) binop -> . binop MINUS binop
    (46) binop -> . binop MUL binop
    (47) binop -> . binop DIV binop
    (48) binop -> . PAREN_OPEN binop PAREN_CLOSE
    (49) value -> . MINUS value
    (50) value -> . INTEGER
    (51) value -> . STRING
    (52) value -> . id
    (55) id -> . NAME
    (56) id -> . VALUE

    PAREN_OPEN      shift and go to state 17
    MINUS           shift and go to state 16
    INTEGER         shift and go to state 21
    STRING          shift and go to state 22
    NAME            shift and go to state 26
    VALUE           shift and go to state 27

    binop                          shift and go to state 60
    value                          shift and go to state 58
    id                             shift and go to state 56

state 20

    (16) func -> FUNC . id PAREN_OPEN typeargs PAREN_CLOSE o_id code_block
    (55) id -> . NAME
    (56) id -> . VALUE

    NAME            shift and go to state 26
    VALUE           shift and go to state 27

    id                             shift and go to state 61

state 21

    (50) value -> INTEGER .

    SEMICOLON       reduce using rule 50 (value -> INTEGER .)
    NEWLINE         reduce using rule 50 (value -> INTEGER .)
    LESS            reduce using rule 50 (value -> INTEGER .)
    GREATER         reduce using rule 50 (value -> INTEGER .)
    LESS_EQ         reduce using rule 50 (value -> INTEGER .)
    GREATER_EQ      reduce using rule 50 (value -> INTEGER .)
    EQUAL           reduce using rule 50 (value -> INTEGER .)
    NOT_EQUAL       reduce using rule 50 (value -> INTEGER .)
    PLUS            reduce using rule 50 (value -> INTEGER .)
    MINUS           reduce using rule 50 (value -> INTEGER .)
    MUL             reduce using rule 50 (value -> INTEGER .)
    DIV             reduce using rule 50 (value -> INTEGER .)
    PAREN_CLOSE     reduce using rule 50 (value -> INTEGER .)
    CURLY_OPEN      reduce using rule 50 (value -> INTEGER .)
    PAREN_OPEN      reduce using rule 50 (value -> INTEGER .)
    IF              reduce using rule 50 (value -> INTEGER .)
    WHILE           reduce using rule 50 (value -> INTEGER .)
    FUNC            reduce using rule 50 (value -> INTEGER .)
    INTEGER         reduce using rule 50 (value -> INTEGER .)
    STRING          reduce using rule 50 (value -> INTEGER .)
    RETURN          reduce using rule 50 (value -> INTEGER .)
    NAME            reduce using rule 50 (value -> INTEGER .)
    VALUE           reduce using rule 50 (value -> INTEGER .)
    $end            reduce using rule 50 (value -> INTEGER .)
    CURLY_CLOSE     reduce using rule 50 (value -> INTEGER .)
    COMMA           reduce using rule 50 (value -> INTEGER .)


state 22

    (51) value -> STRING .

    SEMICOLON       reduce using rule 51 (value -> STRING .)
    NEWLINE         reduce using rule 51 (value -> STRING .)
    LESS            reduce using rule 51 (value -> STRING .)
    GREATER         reduce using rule 51 (value -> STRING .)
    LESS_EQ         reduce using rule 51 (value -> STRING .)
    GREATER_EQ      reduce using rule 51 (value -> STRING .)
    EQUAL           reduce using rule 51 (value -> STRING .)
    NOT_EQUAL       reduce using rule 51 (value -> STRING .)
    PLUS            reduce using rule 51 (value -> STRING .)
    MINUS           reduce using rule 51 (value -> STRING .)
    MUL             reduce using rule 51 (value -> STRING .)
    DIV             reduce using rule 51 (value -> STRING .)
    PAREN_CLOSE     reduce using rule 51 (value -> STRING .)
    CURLY_OPEN      reduce using rule 51 (value -> STRING .)
    PAREN_OPEN      reduce using rule 51 (value -> STRING .)
    IF              reduce using rule 51 (value -> STRING .)
    WHILE           reduce using rule 51 (value -> STRING .)
    FUNC            reduce using rule 51 (value -> STRING .)
    INTEGER         reduce using rule 51 (value -> STRING .)
    STRING          reduce using rule 51 (value -> STRING .)
    RETURN          reduce using rule 51 (value -> STRING .)
    NAME            reduce using rule 51 (value -> STRING .)
    VALUE           reduce using rule 51 (value -> STRING .)
    $end            reduce using rule 51 (value -> STRING .)
    CURLY_CLOSE     reduce using rule 51 (value -> STRING .)
    COMMA           reduce using rule 51 (value -> STRING .)


state 23

    (14) return -> RETURN . binop
    (15) return -> RETURN .
    (37) binop -> . binop LESS binop
    (38) binop -> . binop GREATER binop
    (39) binop -> . binop LESS_EQ binop
    (40) binop -> . binop GREATER_EQ binop
    (41) binop -> . binop EQUAL binop
    (42) binop -> . binop NOT_EQUAL binop
    (43) binop -> . value
    (44) binop -> . binop PLUS binop
    (45) binop -> . binop MINUS binop
    (46) binop -> . binop MUL binop
    (47) binop -> . binop DIV binop
    (48) binop -> . PAREN_OPEN binop PAREN_CLOSE
    (49) value -> . MINUS value
    (50) value -> . INTEGER
    (51) value -> . STRING
    (52) value -> . id
    (55) id -> . NAME
    (56) id -> . VALUE

  ! shift/reduce conflict for PAREN_OPEN resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NAME resolved as shift
  ! shift/reduce conflict for VALUE resolved as shift
    SEMICOLON       reduce using rule 15 (return -> RETURN .)
    NEWLINE         reduce using rule 15 (return -> RETURN .)
    IF              reduce using rule 15 (return -> RETURN .)
    WHILE           reduce using rule 15 (return -> RETURN .)
    FUNC            reduce using rule 15 (return -> RETURN .)
    RETURN          reduce using rule 15 (return -> RETURN .)
    $end            reduce using rule 15 (return -> RETURN .)
    CURLY_CLOSE     reduce using rule 15 (return -> RETURN .)
    PAREN_OPEN      shift and go to state 17
    MINUS           shift and go to state 16
    INTEGER         shift and go to state 21
    STRING          shift and go to state 22
    NAME            shift and go to state 26
    VALUE           shift and go to state 27

  ! PAREN_OPEN      [ reduce using rule 15 (return -> RETURN .) ]
  ! MINUS           [ reduce using rule 15 (return -> RETURN .) ]
  ! INTEGER         [ reduce using rule 15 (return -> RETURN .) ]
  ! STRING          [ reduce using rule 15 (return -> RETURN .) ]
  ! NAME            [ reduce using rule 15 (return -> RETURN .) ]
  ! VALUE           [ reduce using rule 15 (return -> RETURN .) ]

    binop                          shift and go to state 62
    value                          shift and go to state 58
    id                             shift and go to state 56

state 24

    (61) end -> SEMICOLON .

    PAREN_OPEN      reduce using rule 61 (end -> SEMICOLON .)
    IF              reduce using rule 61 (end -> SEMICOLON .)
    WHILE           reduce using rule 61 (end -> SEMICOLON .)
    FUNC            reduce using rule 61 (end -> SEMICOLON .)
    MINUS           reduce using rule 61 (end -> SEMICOLON .)
    INTEGER         reduce using rule 61 (end -> SEMICOLON .)
    STRING          reduce using rule 61 (end -> SEMICOLON .)
    RETURN          reduce using rule 61 (end -> SEMICOLON .)
    SEMICOLON       reduce using rule 61 (end -> SEMICOLON .)
    NEWLINE         reduce using rule 61 (end -> SEMICOLON .)
    NAME            reduce using rule 61 (end -> SEMICOLON .)
    VALUE           reduce using rule 61 (end -> SEMICOLON .)
    $end            reduce using rule 61 (end -> SEMICOLON .)
    CURLY_CLOSE     reduce using rule 61 (end -> SEMICOLON .)


state 25

    (62) end -> NEWLINE .

    PAREN_OPEN      reduce using rule 62 (end -> NEWLINE .)
    IF              reduce using rule 62 (end -> NEWLINE .)
    WHILE           reduce using rule 62 (end -> NEWLINE .)
    FUNC            reduce using rule 62 (end -> NEWLINE .)
    MINUS           reduce using rule 62 (end -> NEWLINE .)
    INTEGER         reduce using rule 62 (end -> NEWLINE .)
    STRING          reduce using rule 62 (end -> NEWLINE .)
    RETURN          reduce using rule 62 (end -> NEWLINE .)
    SEMICOLON       reduce using rule 62 (end -> NEWLINE .)
    NEWLINE         reduce using rule 62 (end -> NEWLINE .)
    NAME            reduce using rule 62 (end -> NEWLINE .)
    VALUE           reduce using rule 62 (end -> NEWLINE .)
    $end            reduce using rule 62 (end -> NEWLINE .)
    CURLY_CLOSE     reduce using rule 62 (end -> NEWLINE .)


state 26

    (55) id -> NAME .

    ASSIGN          reduce using rule 55 (id -> NAME .)
    PAREN_OPEN      reduce using rule 55 (id -> NAME .)
    NAME            reduce using rule 55 (id -> NAME .)
    VALUE           reduce using rule 55 (id -> NAME .)
    SEMICOLON       reduce using rule 55 (id -> NAME .)
    NEWLINE         reduce using rule 55 (id -> NAME .)
    LESS            reduce using rule 55 (id -> NAME .)
    GREATER         reduce using rule 55 (id -> NAME .)
    LESS_EQ         reduce using rule 55 (id -> NAME .)
    GREATER_EQ      reduce using rule 55 (id -> NAME .)
    EQUAL           reduce using rule 55 (id -> NAME .)
    NOT_EQUAL       reduce using rule 55 (id -> NAME .)
    PLUS            reduce using rule 55 (id -> NAME .)
    MINUS           reduce using rule 55 (id -> NAME .)
    MUL             reduce using rule 55 (id -> NAME .)
    DIV             reduce using rule 55 (id -> NAME .)
    COMMA           reduce using rule 55 (id -> NAME .)
    PAREN_CLOSE     reduce using rule 55 (id -> NAME .)
    CURLY_OPEN      reduce using rule 55 (id -> NAME .)
    IF              reduce using rule 55 (id -> NAME .)
    WHILE           reduce using rule 55 (id -> NAME .)
    FUNC            reduce using rule 55 (id -> NAME .)
    INTEGER         reduce using rule 55 (id -> NAME .)
    STRING          reduce using rule 55 (id -> NAME .)
    RETURN          reduce using rule 55 (id -> NAME .)
    $end            reduce using rule 55 (id -> NAME .)
    CURLY_CLOSE     reduce using rule 55 (id -> NAME .)


state 27

    (56) id -> VALUE .

    ASSIGN          reduce using rule 56 (id -> VALUE .)
    PAREN_OPEN      reduce using rule 56 (id -> VALUE .)
    NAME            reduce using rule 56 (id -> VALUE .)
    VALUE           reduce using rule 56 (id -> VALUE .)
    SEMICOLON       reduce using rule 56 (id -> VALUE .)
    NEWLINE         reduce using rule 56 (id -> VALUE .)
    LESS            reduce using rule 56 (id -> VALUE .)
    GREATER         reduce using rule 56 (id -> VALUE .)
    LESS_EQ         reduce using rule 56 (id -> VALUE .)
    GREATER_EQ      reduce using rule 56 (id -> VALUE .)
    EQUAL           reduce using rule 56 (id -> VALUE .)
    NOT_EQUAL       reduce using rule 56 (id -> VALUE .)
    PLUS            reduce using rule 56 (id -> VALUE .)
    MINUS           reduce using rule 56 (id -> VALUE .)
    MUL             reduce using rule 56 (id -> VALUE .)
    DIV             reduce using rule 56 (id -> VALUE .)
    COMMA           reduce using rule 56 (id -> VALUE .)
    PAREN_CLOSE     reduce using rule 56 (id -> VALUE .)
    CURLY_OPEN      reduce using rule 56 (id -> VALUE .)
    IF              reduce using rule 56 (id -> VALUE .)
    WHILE           reduce using rule 56 (id -> VALUE .)
    FUNC            reduce using rule 56 (id -> VALUE .)
    INTEGER         reduce using rule 56 (id -> VALUE .)
    STRING          reduce using rule 56 (id -> VALUE .)
    RETURN          reduce using rule 56 (id -> VALUE .)
    $end            reduce using rule 56 (id -> VALUE .)
    CURLY_CLOSE     reduce using rule 56 (id -> VALUE .)


state 28

    (2) program -> program operation .

    PAREN_OPEN      reduce using rule 2 (program -> program operation .)
    IF              reduce using rule 2 (program -> program operation .)
    WHILE           reduce using rule 2 (program -> program operation .)
    FUNC            reduce using rule 2 (program -> program operation .)
    MINUS           reduce using rule 2 (program -> program operation .)
    INTEGER         reduce using rule 2 (program -> program operation .)
    STRING          reduce using rule 2 (program -> program operation .)
    RETURN          reduce using rule 2 (program -> program operation .)
    SEMICOLON       reduce using rule 2 (program -> program operation .)
    NEWLINE         reduce using rule 2 (program -> program operation .)
    NAME            reduce using rule 2 (program -> program operation .)
    VALUE           reduce using rule 2 (program -> program operation .)
    $end            reduce using rule 2 (program -> program operation .)
    CURLY_CLOSE     reduce using rule 2 (program -> program operation .)


state 29

    (4) operation -> assign o_end .

    PAREN_OPEN      reduce using rule 4 (operation -> assign o_end .)
    IF              reduce using rule 4 (operation -> assign o_end .)
    WHILE           reduce using rule 4 (operation -> assign o_end .)
    FUNC            reduce using rule 4 (operation -> assign o_end .)
    MINUS           reduce using rule 4 (operation -> assign o_end .)
    INTEGER         reduce using rule 4 (operation -> assign o_end .)
    STRING          reduce using rule 4 (operation -> assign o_end .)
    RETURN          reduce using rule 4 (operation -> assign o_end .)
    SEMICOLON       reduce using rule 4 (operation -> assign o_end .)
    NEWLINE         reduce using rule 4 (operation -> assign o_end .)
    NAME            reduce using rule 4 (operation -> assign o_end .)
    VALUE           reduce using rule 4 (operation -> assign o_end .)
    $end            reduce using rule 4 (operation -> assign o_end .)
    CURLY_CLOSE     reduce using rule 4 (operation -> assign o_end .)


state 30

    (59) o_end -> end .

    PAREN_OPEN      reduce using rule 59 (o_end -> end .)
    IF              reduce using rule 59 (o_end -> end .)
    WHILE           reduce using rule 59 (o_end -> end .)
    FUNC            reduce using rule 59 (o_end -> end .)
    MINUS           reduce using rule 59 (o_end -> end .)
    INTEGER         reduce using rule 59 (o_end -> end .)
    STRING          reduce using rule 59 (o_end -> end .)
    RETURN          reduce using rule 59 (o_end -> end .)
    SEMICOLON       reduce using rule 59 (o_end -> end .)
    NEWLINE         reduce using rule 59 (o_end -> end .)
    NAME            reduce using rule 59 (o_end -> end .)
    VALUE           reduce using rule 59 (o_end -> end .)
    $end            reduce using rule 59 (o_end -> end .)
    CURLY_CLOSE     reduce using rule 59 (o_end -> end .)


state 31

    (60) o_end -> empty .

    PAREN_OPEN      reduce using rule 60 (o_end -> empty .)
    IF              reduce using rule 60 (o_end -> empty .)
    WHILE           reduce using rule 60 (o_end -> empty .)
    FUNC            reduce using rule 60 (o_end -> empty .)
    MINUS           reduce using rule 60 (o_end -> empty .)
    INTEGER         reduce using rule 60 (o_end -> empty .)
    STRING          reduce using rule 60 (o_end -> empty .)
    RETURN          reduce using rule 60 (o_end -> empty .)
    SEMICOLON       reduce using rule 60 (o_end -> empty .)
    NEWLINE         reduce using rule 60 (o_end -> empty .)
    NAME            reduce using rule 60 (o_end -> empty .)
    VALUE           reduce using rule 60 (o_end -> empty .)
    $end            reduce using rule 60 (o_end -> empty .)
    CURLY_CLOSE     reduce using rule 60 (o_end -> empty .)


state 32

    (5) operation -> binop end .

    PAREN_OPEN      reduce using rule 5 (operation -> binop end .)
    IF              reduce using rule 5 (operation -> binop end .)
    WHILE           reduce using rule 5 (operation -> binop end .)
    FUNC            reduce using rule 5 (operation -> binop end .)
    MINUS           reduce using rule 5 (operation -> binop end .)
    INTEGER         reduce using rule 5 (operation -> binop end .)
    STRING          reduce using rule 5 (operation -> binop end .)
    RETURN          reduce using rule 5 (operation -> binop end .)
    SEMICOLON       reduce using rule 5 (operation -> binop end .)
    NEWLINE         reduce using rule 5 (operation -> binop end .)
    NAME            reduce using rule 5 (operation -> binop end .)
    VALUE           reduce using rule 5 (operation -> binop end .)
    $end            reduce using rule 5 (operation -> binop end .)
    CURLY_CLOSE     reduce using rule 5 (operation -> binop end .)


state 33

    (37) binop -> binop LESS . binop
    (37) binop -> . binop LESS binop
    (38) binop -> . binop GREATER binop
    (39) binop -> . binop LESS_EQ binop
    (40) binop -> . binop GREATER_EQ binop
    (41) binop -> . binop EQUAL binop
    (42) binop -> . binop NOT_EQUAL binop
    (43) binop -> . value
    (44) binop -> . binop PLUS binop
    (45) binop -> . binop MINUS binop
    (46) binop -> . binop MUL binop
    (47) binop -> . binop DIV binop
    (48) binop -> . PAREN_OPEN binop PAREN_CLOSE
    (49) value -> . MINUS value
    (50) value -> . INTEGER
    (51) value -> . STRING
    (52) value -> . id
    (55) id -> . NAME
    (56) id -> . VALUE

    PAREN_OPEN      shift and go to state 17
    MINUS           shift and go to state 16
    INTEGER         shift and go to state 21
    STRING          shift and go to state 22
    NAME            shift and go to state 26
    VALUE           shift and go to state 27

    binop                          shift and go to state 63
    value                          shift and go to state 58
    id                             shift and go to state 56

state 34

    (38) binop -> binop GREATER . binop
    (37) binop -> . binop LESS binop
    (38) binop -> . binop GREATER binop
    (39) binop -> . binop LESS_EQ binop
    (40) binop -> . binop GREATER_EQ binop
    (41) binop -> . binop EQUAL binop
    (42) binop -> . binop NOT_EQUAL binop
    (43) binop -> . value
    (44) binop -> . binop PLUS binop
    (45) binop -> . binop MINUS binop
    (46) binop -> . binop MUL binop
    (47) binop -> . binop DIV binop
    (48) binop -> . PAREN_OPEN binop PAREN_CLOSE
    (49) value -> . MINUS value
    (50) value -> . INTEGER
    (51) value -> . STRING
    (52) value -> . id
    (55) id -> . NAME
    (56) id -> . VALUE

    PAREN_OPEN      shift and go to state 17
    MINUS           shift and go to state 16
    INTEGER         shift and go to state 21
    STRING          shift and go to state 22
    NAME            shift and go to state 26
    VALUE           shift and go to state 27

    binop                          shift and go to state 64
    value                          shift and go to state 58
    id                             shift and go to state 56

state 35

    (39) binop -> binop LESS_EQ . binop
    (37) binop -> . binop LESS binop
    (38) binop -> . binop GREATER binop
    (39) binop -> . binop LESS_EQ binop
    (40) binop -> . binop GREATER_EQ binop
    (41) binop -> . binop EQUAL binop
    (42) binop -> . binop NOT_EQUAL binop
    (43) binop -> . value
    (44) binop -> . binop PLUS binop
    (45) binop -> . binop MINUS binop
    (46) binop -> . binop MUL binop
    (47) binop -> . binop DIV binop
    (48) binop -> . PAREN_OPEN binop PAREN_CLOSE
    (49) value -> . MINUS value
    (50) value -> . INTEGER
    (51) value -> . STRING
    (52) value -> . id
    (55) id -> . NAME
    (56) id -> . VALUE

    PAREN_OPEN      shift and go to state 17
    MINUS           shift and go to state 16
    INTEGER         shift and go to state 21
    STRING          shift and go to state 22
    NAME            shift and go to state 26
    VALUE           shift and go to state 27

    binop                          shift and go to state 65
    value                          shift and go to state 58
    id                             shift and go to state 56

state 36

    (40) binop -> binop GREATER_EQ . binop
    (37) binop -> . binop LESS binop
    (38) binop -> . binop GREATER binop
    (39) binop -> . binop LESS_EQ binop
    (40) binop -> . binop GREATER_EQ binop
    (41) binop -> . binop EQUAL binop
    (42) binop -> . binop NOT_EQUAL binop
    (43) binop -> . value
    (44) binop -> . binop PLUS binop
    (45) binop -> . binop MINUS binop
    (46) binop -> . binop MUL binop
    (47) binop -> . binop DIV binop
    (48) binop -> . PAREN_OPEN binop PAREN_CLOSE
    (49) value -> . MINUS value
    (50) value -> . INTEGER
    (51) value -> . STRING
    (52) value -> . id
    (55) id -> . NAME
    (56) id -> . VALUE

    PAREN_OPEN      shift and go to state 17
    MINUS           shift and go to state 16
    INTEGER         shift and go to state 21
    STRING          shift and go to state 22
    NAME            shift and go to state 26
    VALUE           shift and go to state 27

    binop                          shift and go to state 66
    value                          shift and go to state 58
    id                             shift and go to state 56

state 37

    (41) binop -> binop EQUAL . binop
    (37) binop -> . binop LESS binop
    (38) binop -> . binop GREATER binop
    (39) binop -> . binop LESS_EQ binop
    (40) binop -> . binop GREATER_EQ binop
    (41) binop -> . binop EQUAL binop
    (42) binop -> . binop NOT_EQUAL binop
    (43) binop -> . value
    (44) binop -> . binop PLUS binop
    (45) binop -> . binop MINUS binop
    (46) binop -> . binop MUL binop
    (47) binop -> . binop DIV binop
    (48) binop -> . PAREN_OPEN binop PAREN_CLOSE
    (49) value -> . MINUS value
    (50) value -> . INTEGER
    (51) value -> . STRING
    (52) value -> . id
    (55) id -> . NAME
    (56) id -> . VALUE

    PAREN_OPEN      shift and go to state 17
    MINUS           shift and go to state 16
    INTEGER         shift and go to state 21
    STRING          shift and go to state 22
    NAME            shift and go to state 26
    VALUE           shift and go to state 27

    binop                          shift and go to state 67
    value                          shift and go to state 58
    id                             shift and go to state 56

state 38

    (42) binop -> binop NOT_EQUAL . binop
    (37) binop -> . binop LESS binop
    (38) binop -> . binop GREATER binop
    (39) binop -> . binop LESS_EQ binop
    (40) binop -> . binop GREATER_EQ binop
    (41) binop -> . binop EQUAL binop
    (42) binop -> . binop NOT_EQUAL binop
    (43) binop -> . value
    (44) binop -> . binop PLUS binop
    (45) binop -> . binop MINUS binop
    (46) binop -> . binop MUL binop
    (47) binop -> . binop DIV binop
    (48) binop -> . PAREN_OPEN binop PAREN_CLOSE
    (49) value -> . MINUS value
    (50) value -> . INTEGER
    (51) value -> . STRING
    (52) value -> . id
    (55) id -> . NAME
    (56) id -> . VALUE

    PAREN_OPEN      shift and go to state 17
    MINUS           shift and go to state 16
    INTEGER         shift and go to state 21
    STRING          shift and go to state 22
    NAME            shift and go to state 26
    VALUE           shift and go to state 27

    binop                          shift and go to state 68
    value                          shift and go to state 58
    id                             shift and go to state 56

state 39

    (44) binop -> binop PLUS . binop
    (37) binop -> . binop LESS binop
    (38) binop -> . binop GREATER binop
    (39) binop -> . binop LESS_EQ binop
    (40) binop -> . binop GREATER_EQ binop
    (41) binop -> . binop EQUAL binop
    (42) binop -> . binop NOT_EQUAL binop
    (43) binop -> . value
    (44) binop -> . binop PLUS binop
    (45) binop -> . binop MINUS binop
    (46) binop -> . binop MUL binop
    (47) binop -> . binop DIV binop
    (48) binop -> . PAREN_OPEN binop PAREN_CLOSE
    (49) value -> . MINUS value
    (50) value -> . INTEGER
    (51) value -> . STRING
    (52) value -> . id
    (55) id -> . NAME
    (56) id -> . VALUE

    PAREN_OPEN      shift and go to state 17
    MINUS           shift and go to state 16
    INTEGER         shift and go to state 21
    STRING          shift and go to state 22
    NAME            shift and go to state 26
    VALUE           shift and go to state 27

    binop                          shift and go to state 69
    value                          shift and go to state 58
    id                             shift and go to state 56

state 40

    (45) binop -> binop MINUS . binop
    (37) binop -> . binop LESS binop
    (38) binop -> . binop GREATER binop
    (39) binop -> . binop LESS_EQ binop
    (40) binop -> . binop GREATER_EQ binop
    (41) binop -> . binop EQUAL binop
    (42) binop -> . binop NOT_EQUAL binop
    (43) binop -> . value
    (44) binop -> . binop PLUS binop
    (45) binop -> . binop MINUS binop
    (46) binop -> . binop MUL binop
    (47) binop -> . binop DIV binop
    (48) binop -> . PAREN_OPEN binop PAREN_CLOSE
    (49) value -> . MINUS value
    (50) value -> . INTEGER
    (51) value -> . STRING
    (52) value -> . id
    (55) id -> . NAME
    (56) id -> . VALUE

    PAREN_OPEN      shift and go to state 17
    MINUS           shift and go to state 16
    INTEGER         shift and go to state 21
    STRING          shift and go to state 22
    NAME            shift and go to state 26
    VALUE           shift and go to state 27

    binop                          shift and go to state 70
    value                          shift and go to state 58
    id                             shift and go to state 56

state 41

    (46) binop -> binop MUL . binop
    (37) binop -> . binop LESS binop
    (38) binop -> . binop GREATER binop
    (39) binop -> . binop LESS_EQ binop
    (40) binop -> . binop GREATER_EQ binop
    (41) binop -> . binop EQUAL binop
    (42) binop -> . binop NOT_EQUAL binop
    (43) binop -> . value
    (44) binop -> . binop PLUS binop
    (45) binop -> . binop MINUS binop
    (46) binop -> . binop MUL binop
    (47) binop -> . binop DIV binop
    (48) binop -> . PAREN_OPEN binop PAREN_CLOSE
    (49) value -> . MINUS value
    (50) value -> . INTEGER
    (51) value -> . STRING
    (52) value -> . id
    (55) id -> . NAME
    (56) id -> . VALUE

    PAREN_OPEN      shift and go to state 17
    MINUS           shift and go to state 16
    INTEGER         shift and go to state 21
    STRING          shift and go to state 22
    NAME            shift and go to state 26
    VALUE           shift and go to state 27

    binop                          shift and go to state 71
    value                          shift and go to state 58
    id                             shift and go to state 56

state 42

    (47) binop -> binop DIV . binop
    (37) binop -> . binop LESS binop
    (38) binop -> . binop GREATER binop
    (39) binop -> . binop LESS_EQ binop
    (40) binop -> . binop GREATER_EQ binop
    (41) binop -> . binop EQUAL binop
    (42) binop -> . binop NOT_EQUAL binop
    (43) binop -> . value
    (44) binop -> . binop PLUS binop
    (45) binop -> . binop MINUS binop
    (46) binop -> . binop MUL binop
    (47) binop -> . binop DIV binop
    (48) binop -> . PAREN_OPEN binop PAREN_CLOSE
    (49) value -> . MINUS value
    (50) value -> . INTEGER
    (51) value -> . STRING
    (52) value -> . id
    (55) id -> . NAME
    (56) id -> . VALUE

    PAREN_OPEN      shift and go to state 17
    MINUS           shift and go to state 16
    INTEGER         shift and go to state 21
    STRING          shift and go to state 22
    NAME            shift and go to state 26
    VALUE           shift and go to state 27

    binop                          shift and go to state 72
    value                          shift and go to state 58
    id                             shift and go to state 56

state 43

    (6) operation -> func_call end .

    PAREN_OPEN      reduce using rule 6 (operation -> func_call end .)
    IF              reduce using rule 6 (operation -> func_call end .)
    WHILE           reduce using rule 6 (operation -> func_call end .)
    FUNC            reduce using rule 6 (operation -> func_call end .)
    MINUS           reduce using rule 6 (operation -> func_call end .)
    INTEGER         reduce using rule 6 (operation -> func_call end .)
    STRING          reduce using rule 6 (operation -> func_call end .)
    RETURN          reduce using rule 6 (operation -> func_call end .)
    SEMICOLON       reduce using rule 6 (operation -> func_call end .)
    NEWLINE         reduce using rule 6 (operation -> func_call end .)
    NAME            reduce using rule 6 (operation -> func_call end .)
    VALUE           reduce using rule 6 (operation -> func_call end .)
    $end            reduce using rule 6 (operation -> func_call end .)
    CURLY_CLOSE     reduce using rule 6 (operation -> func_call end .)


state 44

    (7) operation -> if end .

    PAREN_OPEN      reduce using rule 7 (operation -> if end .)
    IF              reduce using rule 7 (operation -> if end .)
    WHILE           reduce using rule 7 (operation -> if end .)
    FUNC            reduce using rule 7 (operation -> if end .)
    MINUS           reduce using rule 7 (operation -> if end .)
    INTEGER         reduce using rule 7 (operation -> if end .)
    STRING          reduce using rule 7 (operation -> if end .)
    RETURN          reduce using rule 7 (operation -> if end .)
    SEMICOLON       reduce using rule 7 (operation -> if end .)
    NEWLINE         reduce using rule 7 (operation -> if end .)
    NAME            reduce using rule 7 (operation -> if end .)
    VALUE           reduce using rule 7 (operation -> if end .)
    $end            reduce using rule 7 (operation -> if end .)
    CURLY_CLOSE     reduce using rule 7 (operation -> if end .)


state 45

    (8) operation -> while end .

    PAREN_OPEN      reduce using rule 8 (operation -> while end .)
    IF              reduce using rule 8 (operation -> while end .)
    WHILE           reduce using rule 8 (operation -> while end .)
    FUNC            reduce using rule 8 (operation -> while end .)
    MINUS           reduce using rule 8 (operation -> while end .)
    INTEGER         reduce using rule 8 (operation -> while end .)
    STRING          reduce using rule 8 (operation -> while end .)
    RETURN          reduce using rule 8 (operation -> while end .)
    SEMICOLON       reduce using rule 8 (operation -> while end .)
    NEWLINE         reduce using rule 8 (operation -> while end .)
    NAME            reduce using rule 8 (operation -> while end .)
    VALUE           reduce using rule 8 (operation -> while end .)
    $end            reduce using rule 8 (operation -> while end .)
    CURLY_CLOSE     reduce using rule 8 (operation -> while end .)


state 46

    (9) operation -> func end .

    PAREN_OPEN      reduce using rule 9 (operation -> func end .)
    IF              reduce using rule 9 (operation -> func end .)
    WHILE           reduce using rule 9 (operation -> func end .)
    FUNC            reduce using rule 9 (operation -> func end .)
    MINUS           reduce using rule 9 (operation -> func end .)
    INTEGER         reduce using rule 9 (operation -> func end .)
    STRING          reduce using rule 9 (operation -> func end .)
    RETURN          reduce using rule 9 (operation -> func end .)
    SEMICOLON       reduce using rule 9 (operation -> func end .)
    NEWLINE         reduce using rule 9 (operation -> func end .)
    NAME            reduce using rule 9 (operation -> func end .)
    VALUE           reduce using rule 9 (operation -> func end .)
    $end            reduce using rule 9 (operation -> func end .)
    CURLY_CLOSE     reduce using rule 9 (operation -> func end .)


state 47

    (10) operation -> value end .

    PAREN_OPEN      reduce using rule 10 (operation -> value end .)
    IF              reduce using rule 10 (operation -> value end .)
    WHILE           reduce using rule 10 (operation -> value end .)
    FUNC            reduce using rule 10 (operation -> value end .)
    MINUS           reduce using rule 10 (operation -> value end .)
    INTEGER         reduce using rule 10 (operation -> value end .)
    STRING          reduce using rule 10 (operation -> value end .)
    RETURN          reduce using rule 10 (operation -> value end .)
    SEMICOLON       reduce using rule 10 (operation -> value end .)
    NEWLINE         reduce using rule 10 (operation -> value end .)
    NAME            reduce using rule 10 (operation -> value end .)
    VALUE           reduce using rule 10 (operation -> value end .)
    $end            reduce using rule 10 (operation -> value end .)
    CURLY_CLOSE     reduce using rule 10 (operation -> value end .)


state 48

    (11) operation -> return o_end .

    PAREN_OPEN      reduce using rule 11 (operation -> return o_end .)
    IF              reduce using rule 11 (operation -> return o_end .)
    WHILE           reduce using rule 11 (operation -> return o_end .)
    FUNC            reduce using rule 11 (operation -> return o_end .)
    MINUS           reduce using rule 11 (operation -> return o_end .)
    INTEGER         reduce using rule 11 (operation -> return o_end .)
    STRING          reduce using rule 11 (operation -> return o_end .)
    RETURN          reduce using rule 11 (operation -> return o_end .)
    SEMICOLON       reduce using rule 11 (operation -> return o_end .)
    NEWLINE         reduce using rule 11 (operation -> return o_end .)
    NAME            reduce using rule 11 (operation -> return o_end .)
    VALUE           reduce using rule 11 (operation -> return o_end .)
    $end            reduce using rule 11 (operation -> return o_end .)
    CURLY_CLOSE     reduce using rule 11 (operation -> return o_end .)


state 49

    (12) operation -> typed_var end .

    PAREN_OPEN      reduce using rule 12 (operation -> typed_var end .)
    IF              reduce using rule 12 (operation -> typed_var end .)
    WHILE           reduce using rule 12 (operation -> typed_var end .)
    FUNC            reduce using rule 12 (operation -> typed_var end .)
    MINUS           reduce using rule 12 (operation -> typed_var end .)
    INTEGER         reduce using rule 12 (operation -> typed_var end .)
    STRING          reduce using rule 12 (operation -> typed_var end .)
    RETURN          reduce using rule 12 (operation -> typed_var end .)
    SEMICOLON       reduce using rule 12 (operation -> typed_var end .)
    NEWLINE         reduce using rule 12 (operation -> typed_var end .)
    NAME            reduce using rule 12 (operation -> typed_var end .)
    VALUE           reduce using rule 12 (operation -> typed_var end .)
    $end            reduce using rule 12 (operation -> typed_var end .)
    CURLY_CLOSE     reduce using rule 12 (operation -> typed_var end .)


state 50

    (32) typed_var -> id id .

    SEMICOLON       reduce using rule 32 (typed_var -> id id .)
    NEWLINE         reduce using rule 32 (typed_var -> id id .)
    ASSIGN          reduce using rule 32 (typed_var -> id id .)
    COMMA           reduce using rule 32 (typed_var -> id id .)
    PAREN_CLOSE     reduce using rule 32 (typed_var -> id id .)


state 51

    (23) assign -> id ASSIGN . expr
    (33) expr -> . binop
    (34) expr -> . func_call
    (35) expr -> . new
    (37) binop -> . binop LESS binop
    (38) binop -> . binop GREATER binop
    (39) binop -> . binop LESS_EQ binop
    (40) binop -> . binop GREATER_EQ binop
    (41) binop -> . binop EQUAL binop
    (42) binop -> . binop NOT_EQUAL binop
    (43) binop -> . value
    (44) binop -> . binop PLUS binop
    (45) binop -> . binop MINUS binop
    (46) binop -> . binop MUL binop
    (47) binop -> . binop DIV binop
    (48) binop -> . PAREN_OPEN binop PAREN_CLOSE
    (21) func_call -> . id PAREN_OPEN params PAREN_CLOSE
    (22) func_call -> . id PAREN_OPEN PAREN_CLOSE
    (36) new -> . NEW func_call
    (49) value -> . MINUS value
    (50) value -> . INTEGER
    (51) value -> . STRING
    (52) value -> . id
    (55) id -> . NAME
    (56) id -> . VALUE

    PAREN_OPEN      shift and go to state 17
    NEW             shift and go to state 78
    MINUS           shift and go to state 16
    INTEGER         shift and go to state 21
    STRING          shift and go to state 22
    NAME            shift and go to state 26
    VALUE           shift and go to state 27

    id                             shift and go to state 73
    expr                           shift and go to state 74
    binop                          shift and go to state 75
    func_call                      shift and go to state 76
    new                            shift and go to state 77
    value                          shift and go to state 58

state 52

    (21) func_call -> id PAREN_OPEN . params PAREN_CLOSE
    (22) func_call -> id PAREN_OPEN . PAREN_CLOSE
    (25) params -> . params COMMA o_newline expr
    (26) params -> . binop
    (37) binop -> . binop LESS binop
    (38) binop -> . binop GREATER binop
    (39) binop -> . binop LESS_EQ binop
    (40) binop -> . binop GREATER_EQ binop
    (41) binop -> . binop EQUAL binop
    (42) binop -> . binop NOT_EQUAL binop
    (43) binop -> . value
    (44) binop -> . binop PLUS binop
    (45) binop -> . binop MINUS binop
    (46) binop -> . binop MUL binop
    (47) binop -> . binop DIV binop
    (48) binop -> . PAREN_OPEN binop PAREN_CLOSE
    (49) value -> . MINUS value
    (50) value -> . INTEGER
    (51) value -> . STRING
    (52) value -> . id
    (55) id -> . NAME
    (56) id -> . VALUE

    PAREN_CLOSE     shift and go to state 80
    PAREN_OPEN      shift and go to state 17
    MINUS           shift and go to state 16
    INTEGER         shift and go to state 21
    STRING          shift and go to state 22
    NAME            shift and go to state 26
    VALUE           shift and go to state 27

    id                             shift and go to state 56
    params                         shift and go to state 79
    binop                          shift and go to state 81
    value                          shift and go to state 58

state 53

    (24) assign -> onetype_args ASSIGN . expr
    (33) expr -> . binop
    (34) expr -> . func_call
    (35) expr -> . new
    (37) binop -> . binop LESS binop
    (38) binop -> . binop GREATER binop
    (39) binop -> . binop LESS_EQ binop
    (40) binop -> . binop GREATER_EQ binop
    (41) binop -> . binop EQUAL binop
    (42) binop -> . binop NOT_EQUAL binop
    (43) binop -> . value
    (44) binop -> . binop PLUS binop
    (45) binop -> . binop MINUS binop
    (46) binop -> . binop MUL binop
    (47) binop -> . binop DIV binop
    (48) binop -> . PAREN_OPEN binop PAREN_CLOSE
    (21) func_call -> . id PAREN_OPEN params PAREN_CLOSE
    (22) func_call -> . id PAREN_OPEN PAREN_CLOSE
    (36) new -> . NEW func_call
    (49) value -> . MINUS value
    (50) value -> . INTEGER
    (51) value -> . STRING
    (52) value -> . id
    (55) id -> . NAME
    (56) id -> . VALUE

    PAREN_OPEN      shift and go to state 17
    NEW             shift and go to state 78
    MINUS           shift and go to state 16
    INTEGER         shift and go to state 21
    STRING          shift and go to state 22
    NAME            shift and go to state 26
    VALUE           shift and go to state 27

    expr                           shift and go to state 82
    binop                          shift and go to state 75
    func_call                      shift and go to state 76
    new                            shift and go to state 77
    value                          shift and go to state 58
    id                             shift and go to state 73

state 54

    (28) onetype_args -> onetype_args COMMA . o_newline id
    (57) o_newline -> . NEWLINE
    (58) o_newline -> . empty
    (63) empty -> .

    NEWLINE         shift and go to state 84
    NAME            reduce using rule 63 (empty -> .)
    VALUE           reduce using rule 63 (empty -> .)

    o_newline                      shift and go to state 83
    empty                          shift and go to state 85

state 55

    (49) value -> MINUS value .

    SEMICOLON       reduce using rule 49 (value -> MINUS value .)
    NEWLINE         reduce using rule 49 (value -> MINUS value .)
    LESS            reduce using rule 49 (value -> MINUS value .)
    GREATER         reduce using rule 49 (value -> MINUS value .)
    LESS_EQ         reduce using rule 49 (value -> MINUS value .)
    GREATER_EQ      reduce using rule 49 (value -> MINUS value .)
    EQUAL           reduce using rule 49 (value -> MINUS value .)
    NOT_EQUAL       reduce using rule 49 (value -> MINUS value .)
    PLUS            reduce using rule 49 (value -> MINUS value .)
    MINUS           reduce using rule 49 (value -> MINUS value .)
    MUL             reduce using rule 49 (value -> MINUS value .)
    DIV             reduce using rule 49 (value -> MINUS value .)
    PAREN_CLOSE     reduce using rule 49 (value -> MINUS value .)
    CURLY_OPEN      reduce using rule 49 (value -> MINUS value .)
    PAREN_OPEN      reduce using rule 49 (value -> MINUS value .)
    IF              reduce using rule 49 (value -> MINUS value .)
    WHILE           reduce using rule 49 (value -> MINUS value .)
    FUNC            reduce using rule 49 (value -> MINUS value .)
    INTEGER         reduce using rule 49 (value -> MINUS value .)
    STRING          reduce using rule 49 (value -> MINUS value .)
    RETURN          reduce using rule 49 (value -> MINUS value .)
    NAME            reduce using rule 49 (value -> MINUS value .)
    VALUE           reduce using rule 49 (value -> MINUS value .)
    $end            reduce using rule 49 (value -> MINUS value .)
    CURLY_CLOSE     reduce using rule 49 (value -> MINUS value .)
    COMMA           reduce using rule 49 (value -> MINUS value .)


state 56

    (52) value -> id .

    SEMICOLON       reduce using rule 52 (value -> id .)
    NEWLINE         reduce using rule 52 (value -> id .)
    LESS            reduce using rule 52 (value -> id .)
    GREATER         reduce using rule 52 (value -> id .)
    LESS_EQ         reduce using rule 52 (value -> id .)
    GREATER_EQ      reduce using rule 52 (value -> id .)
    EQUAL           reduce using rule 52 (value -> id .)
    NOT_EQUAL       reduce using rule 52 (value -> id .)
    PLUS            reduce using rule 52 (value -> id .)
    MINUS           reduce using rule 52 (value -> id .)
    MUL             reduce using rule 52 (value -> id .)
    DIV             reduce using rule 52 (value -> id .)
    PAREN_CLOSE     reduce using rule 52 (value -> id .)
    CURLY_OPEN      reduce using rule 52 (value -> id .)
    PAREN_OPEN      reduce using rule 52 (value -> id .)
    IF              reduce using rule 52 (value -> id .)
    WHILE           reduce using rule 52 (value -> id .)
    FUNC            reduce using rule 52 (value -> id .)
    INTEGER         reduce using rule 52 (value -> id .)
    STRING          reduce using rule 52 (value -> id .)
    RETURN          reduce using rule 52 (value -> id .)
    NAME            reduce using rule 52 (value -> id .)
    VALUE           reduce using rule 52 (value -> id .)
    $end            reduce using rule 52 (value -> id .)
    CURLY_CLOSE     reduce using rule 52 (value -> id .)
    COMMA           reduce using rule 52 (value -> id .)


state 57

    (48) binop -> PAREN_OPEN binop . PAREN_CLOSE
    (37) binop -> binop . LESS binop
    (38) binop -> binop . GREATER binop
    (39) binop -> binop . LESS_EQ binop
    (40) binop -> binop . GREATER_EQ binop
    (41) binop -> binop . EQUAL binop
    (42) binop -> binop . NOT_EQUAL binop
    (44) binop -> binop . PLUS binop
    (45) binop -> binop . MINUS binop
    (46) binop -> binop . MUL binop
    (47) binop -> binop . DIV binop

    PAREN_CLOSE     shift and go to state 86
    LESS            shift and go to state 33
    GREATER         shift and go to state 34
    LESS_EQ         shift and go to state 35
    GREATER_EQ      shift and go to state 36
    EQUAL           shift and go to state 37
    NOT_EQUAL       shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MUL             shift and go to state 41
    DIV             shift and go to state 42


state 58

    (43) binop -> value .

    PAREN_CLOSE     reduce using rule 43 (binop -> value .)
    LESS            reduce using rule 43 (binop -> value .)
    GREATER         reduce using rule 43 (binop -> value .)
    LESS_EQ         reduce using rule 43 (binop -> value .)
    GREATER_EQ      reduce using rule 43 (binop -> value .)
    EQUAL           reduce using rule 43 (binop -> value .)
    NOT_EQUAL       reduce using rule 43 (binop -> value .)
    PLUS            reduce using rule 43 (binop -> value .)
    MINUS           reduce using rule 43 (binop -> value .)
    MUL             reduce using rule 43 (binop -> value .)
    DIV             reduce using rule 43 (binop -> value .)
    CURLY_OPEN      reduce using rule 43 (binop -> value .)
    SEMICOLON       reduce using rule 43 (binop -> value .)
    NEWLINE         reduce using rule 43 (binop -> value .)
    PAREN_OPEN      reduce using rule 43 (binop -> value .)
    IF              reduce using rule 43 (binop -> value .)
    WHILE           reduce using rule 43 (binop -> value .)
    FUNC            reduce using rule 43 (binop -> value .)
    INTEGER         reduce using rule 43 (binop -> value .)
    STRING          reduce using rule 43 (binop -> value .)
    RETURN          reduce using rule 43 (binop -> value .)
    NAME            reduce using rule 43 (binop -> value .)
    VALUE           reduce using rule 43 (binop -> value .)
    $end            reduce using rule 43 (binop -> value .)
    CURLY_CLOSE     reduce using rule 43 (binop -> value .)
    COMMA           reduce using rule 43 (binop -> value .)


state 59

    (17) if -> IF binop . code_block
    (18) if -> IF binop . code_block ELSE code_block
    (37) binop -> binop . LESS binop
    (38) binop -> binop . GREATER binop
    (39) binop -> binop . LESS_EQ binop
    (40) binop -> binop . GREATER_EQ binop
    (41) binop -> binop . EQUAL binop
    (42) binop -> binop . NOT_EQUAL binop
    (44) binop -> binop . PLUS binop
    (45) binop -> binop . MINUS binop
    (46) binop -> binop . MUL binop
    (47) binop -> binop . DIV binop
    (20) code_block -> . CURLY_OPEN o_newline program CURLY_CLOSE

    LESS            shift and go to state 33
    GREATER         shift and go to state 34
    LESS_EQ         shift and go to state 35
    GREATER_EQ      shift and go to state 36
    EQUAL           shift and go to state 37
    NOT_EQUAL       shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MUL             shift and go to state 41
    DIV             shift and go to state 42
    CURLY_OPEN      shift and go to state 88

    code_block                     shift and go to state 87

state 60

    (19) while -> WHILE binop . code_block
    (37) binop -> binop . LESS binop
    (38) binop -> binop . GREATER binop
    (39) binop -> binop . LESS_EQ binop
    (40) binop -> binop . GREATER_EQ binop
    (41) binop -> binop . EQUAL binop
    (42) binop -> binop . NOT_EQUAL binop
    (44) binop -> binop . PLUS binop
    (45) binop -> binop . MINUS binop
    (46) binop -> binop . MUL binop
    (47) binop -> binop . DIV binop
    (20) code_block -> . CURLY_OPEN o_newline program CURLY_CLOSE

    LESS            shift and go to state 33
    GREATER         shift and go to state 34
    LESS_EQ         shift and go to state 35
    GREATER_EQ      shift and go to state 36
    EQUAL           shift and go to state 37
    NOT_EQUAL       shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MUL             shift and go to state 41
    DIV             shift and go to state 42
    CURLY_OPEN      shift and go to state 88

    code_block                     shift and go to state 89

state 61

    (16) func -> FUNC id . PAREN_OPEN typeargs PAREN_CLOSE o_id code_block

    PAREN_OPEN      shift and go to state 90


state 62

    (14) return -> RETURN binop .
    (37) binop -> binop . LESS binop
    (38) binop -> binop . GREATER binop
    (39) binop -> binop . LESS_EQ binop
    (40) binop -> binop . GREATER_EQ binop
    (41) binop -> binop . EQUAL binop
    (42) binop -> binop . NOT_EQUAL binop
    (44) binop -> binop . PLUS binop
    (45) binop -> binop . MINUS binop
    (46) binop -> binop . MUL binop
    (47) binop -> binop . DIV binop

  ! shift/reduce conflict for MINUS resolved as shift
    SEMICOLON       reduce using rule 14 (return -> RETURN binop .)
    NEWLINE         reduce using rule 14 (return -> RETURN binop .)
    PAREN_OPEN      reduce using rule 14 (return -> RETURN binop .)
    IF              reduce using rule 14 (return -> RETURN binop .)
    WHILE           reduce using rule 14 (return -> RETURN binop .)
    FUNC            reduce using rule 14 (return -> RETURN binop .)
    INTEGER         reduce using rule 14 (return -> RETURN binop .)
    STRING          reduce using rule 14 (return -> RETURN binop .)
    RETURN          reduce using rule 14 (return -> RETURN binop .)
    NAME            reduce using rule 14 (return -> RETURN binop .)
    VALUE           reduce using rule 14 (return -> RETURN binop .)
    $end            reduce using rule 14 (return -> RETURN binop .)
    CURLY_CLOSE     reduce using rule 14 (return -> RETURN binop .)
    LESS            shift and go to state 33
    GREATER         shift and go to state 34
    LESS_EQ         shift and go to state 35
    GREATER_EQ      shift and go to state 36
    EQUAL           shift and go to state 37
    NOT_EQUAL       shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MUL             shift and go to state 41
    DIV             shift and go to state 42

  ! MINUS           [ reduce using rule 14 (return -> RETURN binop .) ]


state 63

    (37) binop -> binop LESS binop .
    (37) binop -> binop . LESS binop
    (38) binop -> binop . GREATER binop
    (39) binop -> binop . LESS_EQ binop
    (40) binop -> binop . GREATER_EQ binop
    (41) binop -> binop . EQUAL binop
    (42) binop -> binop . NOT_EQUAL binop
    (44) binop -> binop . PLUS binop
    (45) binop -> binop . MINUS binop
    (46) binop -> binop . MUL binop
    (47) binop -> binop . DIV binop

    LESS            reduce using rule 37 (binop -> binop LESS binop .)
    GREATER         reduce using rule 37 (binop -> binop LESS binop .)
    EQUAL           reduce using rule 37 (binop -> binop LESS binop .)
    NOT_EQUAL       reduce using rule 37 (binop -> binop LESS binop .)
    SEMICOLON       reduce using rule 37 (binop -> binop LESS binop .)
    NEWLINE         reduce using rule 37 (binop -> binop LESS binop .)
    PAREN_CLOSE     reduce using rule 37 (binop -> binop LESS binop .)
    CURLY_OPEN      reduce using rule 37 (binop -> binop LESS binop .)
    PAREN_OPEN      reduce using rule 37 (binop -> binop LESS binop .)
    IF              reduce using rule 37 (binop -> binop LESS binop .)
    WHILE           reduce using rule 37 (binop -> binop LESS binop .)
    FUNC            reduce using rule 37 (binop -> binop LESS binop .)
    INTEGER         reduce using rule 37 (binop -> binop LESS binop .)
    STRING          reduce using rule 37 (binop -> binop LESS binop .)
    RETURN          reduce using rule 37 (binop -> binop LESS binop .)
    NAME            reduce using rule 37 (binop -> binop LESS binop .)
    VALUE           reduce using rule 37 (binop -> binop LESS binop .)
    $end            reduce using rule 37 (binop -> binop LESS binop .)
    CURLY_CLOSE     reduce using rule 37 (binop -> binop LESS binop .)
    COMMA           reduce using rule 37 (binop -> binop LESS binop .)
    LESS_EQ         shift and go to state 35
    GREATER_EQ      shift and go to state 36
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MUL             shift and go to state 41
    DIV             shift and go to state 42

  ! LESS_EQ         [ reduce using rule 37 (binop -> binop LESS binop .) ]
  ! GREATER_EQ      [ reduce using rule 37 (binop -> binop LESS binop .) ]
  ! PLUS            [ reduce using rule 37 (binop -> binop LESS binop .) ]
  ! MINUS           [ reduce using rule 37 (binop -> binop LESS binop .) ]
  ! MUL             [ reduce using rule 37 (binop -> binop LESS binop .) ]
  ! DIV             [ reduce using rule 37 (binop -> binop LESS binop .) ]
  ! LESS            [ shift and go to state 33 ]
  ! GREATER         [ shift and go to state 34 ]
  ! EQUAL           [ shift and go to state 37 ]
  ! NOT_EQUAL       [ shift and go to state 38 ]


state 64

    (38) binop -> binop GREATER binop .
    (37) binop -> binop . LESS binop
    (38) binop -> binop . GREATER binop
    (39) binop -> binop . LESS_EQ binop
    (40) binop -> binop . GREATER_EQ binop
    (41) binop -> binop . EQUAL binop
    (42) binop -> binop . NOT_EQUAL binop
    (44) binop -> binop . PLUS binop
    (45) binop -> binop . MINUS binop
    (46) binop -> binop . MUL binop
    (47) binop -> binop . DIV binop

    LESS            reduce using rule 38 (binop -> binop GREATER binop .)
    GREATER         reduce using rule 38 (binop -> binop GREATER binop .)
    EQUAL           reduce using rule 38 (binop -> binop GREATER binop .)
    NOT_EQUAL       reduce using rule 38 (binop -> binop GREATER binop .)
    SEMICOLON       reduce using rule 38 (binop -> binop GREATER binop .)
    NEWLINE         reduce using rule 38 (binop -> binop GREATER binop .)
    PAREN_CLOSE     reduce using rule 38 (binop -> binop GREATER binop .)
    CURLY_OPEN      reduce using rule 38 (binop -> binop GREATER binop .)
    PAREN_OPEN      reduce using rule 38 (binop -> binop GREATER binop .)
    IF              reduce using rule 38 (binop -> binop GREATER binop .)
    WHILE           reduce using rule 38 (binop -> binop GREATER binop .)
    FUNC            reduce using rule 38 (binop -> binop GREATER binop .)
    INTEGER         reduce using rule 38 (binop -> binop GREATER binop .)
    STRING          reduce using rule 38 (binop -> binop GREATER binop .)
    RETURN          reduce using rule 38 (binop -> binop GREATER binop .)
    NAME            reduce using rule 38 (binop -> binop GREATER binop .)
    VALUE           reduce using rule 38 (binop -> binop GREATER binop .)
    $end            reduce using rule 38 (binop -> binop GREATER binop .)
    CURLY_CLOSE     reduce using rule 38 (binop -> binop GREATER binop .)
    COMMA           reduce using rule 38 (binop -> binop GREATER binop .)
    LESS_EQ         shift and go to state 35
    GREATER_EQ      shift and go to state 36
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MUL             shift and go to state 41
    DIV             shift and go to state 42

  ! LESS_EQ         [ reduce using rule 38 (binop -> binop GREATER binop .) ]
  ! GREATER_EQ      [ reduce using rule 38 (binop -> binop GREATER binop .) ]
  ! PLUS            [ reduce using rule 38 (binop -> binop GREATER binop .) ]
  ! MINUS           [ reduce using rule 38 (binop -> binop GREATER binop .) ]
  ! MUL             [ reduce using rule 38 (binop -> binop GREATER binop .) ]
  ! DIV             [ reduce using rule 38 (binop -> binop GREATER binop .) ]
  ! LESS            [ shift and go to state 33 ]
  ! GREATER         [ shift and go to state 34 ]
  ! EQUAL           [ shift and go to state 37 ]
  ! NOT_EQUAL       [ shift and go to state 38 ]


state 65

    (39) binop -> binop LESS_EQ binop .
    (37) binop -> binop . LESS binop
    (38) binop -> binop . GREATER binop
    (39) binop -> binop . LESS_EQ binop
    (40) binop -> binop . GREATER_EQ binop
    (41) binop -> binop . EQUAL binop
    (42) binop -> binop . NOT_EQUAL binop
    (44) binop -> binop . PLUS binop
    (45) binop -> binop . MINUS binop
    (46) binop -> binop . MUL binop
    (47) binop -> binop . DIV binop

    LESS            reduce using rule 39 (binop -> binop LESS_EQ binop .)
    GREATER         reduce using rule 39 (binop -> binop LESS_EQ binop .)
    LESS_EQ         reduce using rule 39 (binop -> binop LESS_EQ binop .)
    GREATER_EQ      reduce using rule 39 (binop -> binop LESS_EQ binop .)
    EQUAL           reduce using rule 39 (binop -> binop LESS_EQ binop .)
    NOT_EQUAL       reduce using rule 39 (binop -> binop LESS_EQ binop .)
    SEMICOLON       reduce using rule 39 (binop -> binop LESS_EQ binop .)
    NEWLINE         reduce using rule 39 (binop -> binop LESS_EQ binop .)
    PAREN_CLOSE     reduce using rule 39 (binop -> binop LESS_EQ binop .)
    CURLY_OPEN      reduce using rule 39 (binop -> binop LESS_EQ binop .)
    PAREN_OPEN      reduce using rule 39 (binop -> binop LESS_EQ binop .)
    IF              reduce using rule 39 (binop -> binop LESS_EQ binop .)
    WHILE           reduce using rule 39 (binop -> binop LESS_EQ binop .)
    FUNC            reduce using rule 39 (binop -> binop LESS_EQ binop .)
    INTEGER         reduce using rule 39 (binop -> binop LESS_EQ binop .)
    STRING          reduce using rule 39 (binop -> binop LESS_EQ binop .)
    RETURN          reduce using rule 39 (binop -> binop LESS_EQ binop .)
    NAME            reduce using rule 39 (binop -> binop LESS_EQ binop .)
    VALUE           reduce using rule 39 (binop -> binop LESS_EQ binop .)
    $end            reduce using rule 39 (binop -> binop LESS_EQ binop .)
    CURLY_CLOSE     reduce using rule 39 (binop -> binop LESS_EQ binop .)
    COMMA           reduce using rule 39 (binop -> binop LESS_EQ binop .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MUL             shift and go to state 41
    DIV             shift and go to state 42

  ! PLUS            [ reduce using rule 39 (binop -> binop LESS_EQ binop .) ]
  ! MINUS           [ reduce using rule 39 (binop -> binop LESS_EQ binop .) ]
  ! MUL             [ reduce using rule 39 (binop -> binop LESS_EQ binop .) ]
  ! DIV             [ reduce using rule 39 (binop -> binop LESS_EQ binop .) ]
  ! LESS            [ shift and go to state 33 ]
  ! GREATER         [ shift and go to state 34 ]
  ! LESS_EQ         [ shift and go to state 35 ]
  ! GREATER_EQ      [ shift and go to state 36 ]
  ! EQUAL           [ shift and go to state 37 ]
  ! NOT_EQUAL       [ shift and go to state 38 ]


state 66

    (40) binop -> binop GREATER_EQ binop .
    (37) binop -> binop . LESS binop
    (38) binop -> binop . GREATER binop
    (39) binop -> binop . LESS_EQ binop
    (40) binop -> binop . GREATER_EQ binop
    (41) binop -> binop . EQUAL binop
    (42) binop -> binop . NOT_EQUAL binop
    (44) binop -> binop . PLUS binop
    (45) binop -> binop . MINUS binop
    (46) binop -> binop . MUL binop
    (47) binop -> binop . DIV binop

    LESS            reduce using rule 40 (binop -> binop GREATER_EQ binop .)
    GREATER         reduce using rule 40 (binop -> binop GREATER_EQ binop .)
    LESS_EQ         reduce using rule 40 (binop -> binop GREATER_EQ binop .)
    GREATER_EQ      reduce using rule 40 (binop -> binop GREATER_EQ binop .)
    EQUAL           reduce using rule 40 (binop -> binop GREATER_EQ binop .)
    NOT_EQUAL       reduce using rule 40 (binop -> binop GREATER_EQ binop .)
    SEMICOLON       reduce using rule 40 (binop -> binop GREATER_EQ binop .)
    NEWLINE         reduce using rule 40 (binop -> binop GREATER_EQ binop .)
    PAREN_CLOSE     reduce using rule 40 (binop -> binop GREATER_EQ binop .)
    CURLY_OPEN      reduce using rule 40 (binop -> binop GREATER_EQ binop .)
    PAREN_OPEN      reduce using rule 40 (binop -> binop GREATER_EQ binop .)
    IF              reduce using rule 40 (binop -> binop GREATER_EQ binop .)
    WHILE           reduce using rule 40 (binop -> binop GREATER_EQ binop .)
    FUNC            reduce using rule 40 (binop -> binop GREATER_EQ binop .)
    INTEGER         reduce using rule 40 (binop -> binop GREATER_EQ binop .)
    STRING          reduce using rule 40 (binop -> binop GREATER_EQ binop .)
    RETURN          reduce using rule 40 (binop -> binop GREATER_EQ binop .)
    NAME            reduce using rule 40 (binop -> binop GREATER_EQ binop .)
    VALUE           reduce using rule 40 (binop -> binop GREATER_EQ binop .)
    $end            reduce using rule 40 (binop -> binop GREATER_EQ binop .)
    CURLY_CLOSE     reduce using rule 40 (binop -> binop GREATER_EQ binop .)
    COMMA           reduce using rule 40 (binop -> binop GREATER_EQ binop .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MUL             shift and go to state 41
    DIV             shift and go to state 42

  ! PLUS            [ reduce using rule 40 (binop -> binop GREATER_EQ binop .) ]
  ! MINUS           [ reduce using rule 40 (binop -> binop GREATER_EQ binop .) ]
  ! MUL             [ reduce using rule 40 (binop -> binop GREATER_EQ binop .) ]
  ! DIV             [ reduce using rule 40 (binop -> binop GREATER_EQ binop .) ]
  ! LESS            [ shift and go to state 33 ]
  ! GREATER         [ shift and go to state 34 ]
  ! LESS_EQ         [ shift and go to state 35 ]
  ! GREATER_EQ      [ shift and go to state 36 ]
  ! EQUAL           [ shift and go to state 37 ]
  ! NOT_EQUAL       [ shift and go to state 38 ]


state 67

    (41) binop -> binop EQUAL binop .
    (37) binop -> binop . LESS binop
    (38) binop -> binop . GREATER binop
    (39) binop -> binop . LESS_EQ binop
    (40) binop -> binop . GREATER_EQ binop
    (41) binop -> binop . EQUAL binop
    (42) binop -> binop . NOT_EQUAL binop
    (44) binop -> binop . PLUS binop
    (45) binop -> binop . MINUS binop
    (46) binop -> binop . MUL binop
    (47) binop -> binop . DIV binop

    EQUAL           reduce using rule 41 (binop -> binop EQUAL binop .)
    NOT_EQUAL       reduce using rule 41 (binop -> binop EQUAL binop .)
    SEMICOLON       reduce using rule 41 (binop -> binop EQUAL binop .)
    NEWLINE         reduce using rule 41 (binop -> binop EQUAL binop .)
    PAREN_CLOSE     reduce using rule 41 (binop -> binop EQUAL binop .)
    CURLY_OPEN      reduce using rule 41 (binop -> binop EQUAL binop .)
    PAREN_OPEN      reduce using rule 41 (binop -> binop EQUAL binop .)
    IF              reduce using rule 41 (binop -> binop EQUAL binop .)
    WHILE           reduce using rule 41 (binop -> binop EQUAL binop .)
    FUNC            reduce using rule 41 (binop -> binop EQUAL binop .)
    INTEGER         reduce using rule 41 (binop -> binop EQUAL binop .)
    STRING          reduce using rule 41 (binop -> binop EQUAL binop .)
    RETURN          reduce using rule 41 (binop -> binop EQUAL binop .)
    NAME            reduce using rule 41 (binop -> binop EQUAL binop .)
    VALUE           reduce using rule 41 (binop -> binop EQUAL binop .)
    $end            reduce using rule 41 (binop -> binop EQUAL binop .)
    CURLY_CLOSE     reduce using rule 41 (binop -> binop EQUAL binop .)
    COMMA           reduce using rule 41 (binop -> binop EQUAL binop .)
    LESS            shift and go to state 33
    GREATER         shift and go to state 34
    LESS_EQ         shift and go to state 35
    GREATER_EQ      shift and go to state 36
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MUL             shift and go to state 41
    DIV             shift and go to state 42

  ! LESS            [ reduce using rule 41 (binop -> binop EQUAL binop .) ]
  ! GREATER         [ reduce using rule 41 (binop -> binop EQUAL binop .) ]
  ! LESS_EQ         [ reduce using rule 41 (binop -> binop EQUAL binop .) ]
  ! GREATER_EQ      [ reduce using rule 41 (binop -> binop EQUAL binop .) ]
  ! PLUS            [ reduce using rule 41 (binop -> binop EQUAL binop .) ]
  ! MINUS           [ reduce using rule 41 (binop -> binop EQUAL binop .) ]
  ! MUL             [ reduce using rule 41 (binop -> binop EQUAL binop .) ]
  ! DIV             [ reduce using rule 41 (binop -> binop EQUAL binop .) ]
  ! EQUAL           [ shift and go to state 37 ]
  ! NOT_EQUAL       [ shift and go to state 38 ]


state 68

    (42) binop -> binop NOT_EQUAL binop .
    (37) binop -> binop . LESS binop
    (38) binop -> binop . GREATER binop
    (39) binop -> binop . LESS_EQ binop
    (40) binop -> binop . GREATER_EQ binop
    (41) binop -> binop . EQUAL binop
    (42) binop -> binop . NOT_EQUAL binop
    (44) binop -> binop . PLUS binop
    (45) binop -> binop . MINUS binop
    (46) binop -> binop . MUL binop
    (47) binop -> binop . DIV binop

    EQUAL           reduce using rule 42 (binop -> binop NOT_EQUAL binop .)
    NOT_EQUAL       reduce using rule 42 (binop -> binop NOT_EQUAL binop .)
    SEMICOLON       reduce using rule 42 (binop -> binop NOT_EQUAL binop .)
    NEWLINE         reduce using rule 42 (binop -> binop NOT_EQUAL binop .)
    PAREN_CLOSE     reduce using rule 42 (binop -> binop NOT_EQUAL binop .)
    CURLY_OPEN      reduce using rule 42 (binop -> binop NOT_EQUAL binop .)
    PAREN_OPEN      reduce using rule 42 (binop -> binop NOT_EQUAL binop .)
    IF              reduce using rule 42 (binop -> binop NOT_EQUAL binop .)
    WHILE           reduce using rule 42 (binop -> binop NOT_EQUAL binop .)
    FUNC            reduce using rule 42 (binop -> binop NOT_EQUAL binop .)
    INTEGER         reduce using rule 42 (binop -> binop NOT_EQUAL binop .)
    STRING          reduce using rule 42 (binop -> binop NOT_EQUAL binop .)
    RETURN          reduce using rule 42 (binop -> binop NOT_EQUAL binop .)
    NAME            reduce using rule 42 (binop -> binop NOT_EQUAL binop .)
    VALUE           reduce using rule 42 (binop -> binop NOT_EQUAL binop .)
    $end            reduce using rule 42 (binop -> binop NOT_EQUAL binop .)
    CURLY_CLOSE     reduce using rule 42 (binop -> binop NOT_EQUAL binop .)
    COMMA           reduce using rule 42 (binop -> binop NOT_EQUAL binop .)
    LESS            shift and go to state 33
    GREATER         shift and go to state 34
    LESS_EQ         shift and go to state 35
    GREATER_EQ      shift and go to state 36
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MUL             shift and go to state 41
    DIV             shift and go to state 42

  ! LESS            [ reduce using rule 42 (binop -> binop NOT_EQUAL binop .) ]
  ! GREATER         [ reduce using rule 42 (binop -> binop NOT_EQUAL binop .) ]
  ! LESS_EQ         [ reduce using rule 42 (binop -> binop NOT_EQUAL binop .) ]
  ! GREATER_EQ      [ reduce using rule 42 (binop -> binop NOT_EQUAL binop .) ]
  ! PLUS            [ reduce using rule 42 (binop -> binop NOT_EQUAL binop .) ]
  ! MINUS           [ reduce using rule 42 (binop -> binop NOT_EQUAL binop .) ]
  ! MUL             [ reduce using rule 42 (binop -> binop NOT_EQUAL binop .) ]
  ! DIV             [ reduce using rule 42 (binop -> binop NOT_EQUAL binop .) ]
  ! EQUAL           [ shift and go to state 37 ]
  ! NOT_EQUAL       [ shift and go to state 38 ]


state 69

    (44) binop -> binop PLUS binop .
    (37) binop -> binop . LESS binop
    (38) binop -> binop . GREATER binop
    (39) binop -> binop . LESS_EQ binop
    (40) binop -> binop . GREATER_EQ binop
    (41) binop -> binop . EQUAL binop
    (42) binop -> binop . NOT_EQUAL binop
    (44) binop -> binop . PLUS binop
    (45) binop -> binop . MINUS binop
    (46) binop -> binop . MUL binop
    (47) binop -> binop . DIV binop

    LESS            reduce using rule 44 (binop -> binop PLUS binop .)
    GREATER         reduce using rule 44 (binop -> binop PLUS binop .)
    LESS_EQ         reduce using rule 44 (binop -> binop PLUS binop .)
    GREATER_EQ      reduce using rule 44 (binop -> binop PLUS binop .)
    EQUAL           reduce using rule 44 (binop -> binop PLUS binop .)
    NOT_EQUAL       reduce using rule 44 (binop -> binop PLUS binop .)
    PLUS            reduce using rule 44 (binop -> binop PLUS binop .)
    MINUS           reduce using rule 44 (binop -> binop PLUS binop .)
    SEMICOLON       reduce using rule 44 (binop -> binop PLUS binop .)
    NEWLINE         reduce using rule 44 (binop -> binop PLUS binop .)
    PAREN_CLOSE     reduce using rule 44 (binop -> binop PLUS binop .)
    CURLY_OPEN      reduce using rule 44 (binop -> binop PLUS binop .)
    PAREN_OPEN      reduce using rule 44 (binop -> binop PLUS binop .)
    IF              reduce using rule 44 (binop -> binop PLUS binop .)
    WHILE           reduce using rule 44 (binop -> binop PLUS binop .)
    FUNC            reduce using rule 44 (binop -> binop PLUS binop .)
    INTEGER         reduce using rule 44 (binop -> binop PLUS binop .)
    STRING          reduce using rule 44 (binop -> binop PLUS binop .)
    RETURN          reduce using rule 44 (binop -> binop PLUS binop .)
    NAME            reduce using rule 44 (binop -> binop PLUS binop .)
    VALUE           reduce using rule 44 (binop -> binop PLUS binop .)
    $end            reduce using rule 44 (binop -> binop PLUS binop .)
    CURLY_CLOSE     reduce using rule 44 (binop -> binop PLUS binop .)
    COMMA           reduce using rule 44 (binop -> binop PLUS binop .)
    MUL             shift and go to state 41
    DIV             shift and go to state 42

  ! MUL             [ reduce using rule 44 (binop -> binop PLUS binop .) ]
  ! DIV             [ reduce using rule 44 (binop -> binop PLUS binop .) ]
  ! LESS            [ shift and go to state 33 ]
  ! GREATER         [ shift and go to state 34 ]
  ! LESS_EQ         [ shift and go to state 35 ]
  ! GREATER_EQ      [ shift and go to state 36 ]
  ! EQUAL           [ shift and go to state 37 ]
  ! NOT_EQUAL       [ shift and go to state 38 ]
  ! PLUS            [ shift and go to state 39 ]
  ! MINUS           [ shift and go to state 40 ]


state 70

    (45) binop -> binop MINUS binop .
    (37) binop -> binop . LESS binop
    (38) binop -> binop . GREATER binop
    (39) binop -> binop . LESS_EQ binop
    (40) binop -> binop . GREATER_EQ binop
    (41) binop -> binop . EQUAL binop
    (42) binop -> binop . NOT_EQUAL binop
    (44) binop -> binop . PLUS binop
    (45) binop -> binop . MINUS binop
    (46) binop -> binop . MUL binop
    (47) binop -> binop . DIV binop

    LESS            reduce using rule 45 (binop -> binop MINUS binop .)
    GREATER         reduce using rule 45 (binop -> binop MINUS binop .)
    LESS_EQ         reduce using rule 45 (binop -> binop MINUS binop .)
    GREATER_EQ      reduce using rule 45 (binop -> binop MINUS binop .)
    EQUAL           reduce using rule 45 (binop -> binop MINUS binop .)
    NOT_EQUAL       reduce using rule 45 (binop -> binop MINUS binop .)
    PLUS            reduce using rule 45 (binop -> binop MINUS binop .)
    MINUS           reduce using rule 45 (binop -> binop MINUS binop .)
    SEMICOLON       reduce using rule 45 (binop -> binop MINUS binop .)
    NEWLINE         reduce using rule 45 (binop -> binop MINUS binop .)
    PAREN_CLOSE     reduce using rule 45 (binop -> binop MINUS binop .)
    CURLY_OPEN      reduce using rule 45 (binop -> binop MINUS binop .)
    PAREN_OPEN      reduce using rule 45 (binop -> binop MINUS binop .)
    IF              reduce using rule 45 (binop -> binop MINUS binop .)
    WHILE           reduce using rule 45 (binop -> binop MINUS binop .)
    FUNC            reduce using rule 45 (binop -> binop MINUS binop .)
    INTEGER         reduce using rule 45 (binop -> binop MINUS binop .)
    STRING          reduce using rule 45 (binop -> binop MINUS binop .)
    RETURN          reduce using rule 45 (binop -> binop MINUS binop .)
    NAME            reduce using rule 45 (binop -> binop MINUS binop .)
    VALUE           reduce using rule 45 (binop -> binop MINUS binop .)
    $end            reduce using rule 45 (binop -> binop MINUS binop .)
    CURLY_CLOSE     reduce using rule 45 (binop -> binop MINUS binop .)
    COMMA           reduce using rule 45 (binop -> binop MINUS binop .)
    MUL             shift and go to state 41
    DIV             shift and go to state 42

  ! MUL             [ reduce using rule 45 (binop -> binop MINUS binop .) ]
  ! DIV             [ reduce using rule 45 (binop -> binop MINUS binop .) ]
  ! LESS            [ shift and go to state 33 ]
  ! GREATER         [ shift and go to state 34 ]
  ! LESS_EQ         [ shift and go to state 35 ]
  ! GREATER_EQ      [ shift and go to state 36 ]
  ! EQUAL           [ shift and go to state 37 ]
  ! NOT_EQUAL       [ shift and go to state 38 ]
  ! PLUS            [ shift and go to state 39 ]
  ! MINUS           [ shift and go to state 40 ]


state 71

    (46) binop -> binop MUL binop .
    (37) binop -> binop . LESS binop
    (38) binop -> binop . GREATER binop
    (39) binop -> binop . LESS_EQ binop
    (40) binop -> binop . GREATER_EQ binop
    (41) binop -> binop . EQUAL binop
    (42) binop -> binop . NOT_EQUAL binop
    (44) binop -> binop . PLUS binop
    (45) binop -> binop . MINUS binop
    (46) binop -> binop . MUL binop
    (47) binop -> binop . DIV binop

    LESS            reduce using rule 46 (binop -> binop MUL binop .)
    GREATER         reduce using rule 46 (binop -> binop MUL binop .)
    LESS_EQ         reduce using rule 46 (binop -> binop MUL binop .)
    GREATER_EQ      reduce using rule 46 (binop -> binop MUL binop .)
    EQUAL           reduce using rule 46 (binop -> binop MUL binop .)
    NOT_EQUAL       reduce using rule 46 (binop -> binop MUL binop .)
    PLUS            reduce using rule 46 (binop -> binop MUL binop .)
    MINUS           reduce using rule 46 (binop -> binop MUL binop .)
    MUL             reduce using rule 46 (binop -> binop MUL binop .)
    DIV             reduce using rule 46 (binop -> binop MUL binop .)
    SEMICOLON       reduce using rule 46 (binop -> binop MUL binop .)
    NEWLINE         reduce using rule 46 (binop -> binop MUL binop .)
    PAREN_CLOSE     reduce using rule 46 (binop -> binop MUL binop .)
    CURLY_OPEN      reduce using rule 46 (binop -> binop MUL binop .)
    PAREN_OPEN      reduce using rule 46 (binop -> binop MUL binop .)
    IF              reduce using rule 46 (binop -> binop MUL binop .)
    WHILE           reduce using rule 46 (binop -> binop MUL binop .)
    FUNC            reduce using rule 46 (binop -> binop MUL binop .)
    INTEGER         reduce using rule 46 (binop -> binop MUL binop .)
    STRING          reduce using rule 46 (binop -> binop MUL binop .)
    RETURN          reduce using rule 46 (binop -> binop MUL binop .)
    NAME            reduce using rule 46 (binop -> binop MUL binop .)
    VALUE           reduce using rule 46 (binop -> binop MUL binop .)
    $end            reduce using rule 46 (binop -> binop MUL binop .)
    CURLY_CLOSE     reduce using rule 46 (binop -> binop MUL binop .)
    COMMA           reduce using rule 46 (binop -> binop MUL binop .)

  ! LESS            [ shift and go to state 33 ]
  ! GREATER         [ shift and go to state 34 ]
  ! LESS_EQ         [ shift and go to state 35 ]
  ! GREATER_EQ      [ shift and go to state 36 ]
  ! EQUAL           [ shift and go to state 37 ]
  ! NOT_EQUAL       [ shift and go to state 38 ]
  ! PLUS            [ shift and go to state 39 ]
  ! MINUS           [ shift and go to state 40 ]
  ! MUL             [ shift and go to state 41 ]
  ! DIV             [ shift and go to state 42 ]


state 72

    (47) binop -> binop DIV binop .
    (37) binop -> binop . LESS binop
    (38) binop -> binop . GREATER binop
    (39) binop -> binop . LESS_EQ binop
    (40) binop -> binop . GREATER_EQ binop
    (41) binop -> binop . EQUAL binop
    (42) binop -> binop . NOT_EQUAL binop
    (44) binop -> binop . PLUS binop
    (45) binop -> binop . MINUS binop
    (46) binop -> binop . MUL binop
    (47) binop -> binop . DIV binop

    LESS            reduce using rule 47 (binop -> binop DIV binop .)
    GREATER         reduce using rule 47 (binop -> binop DIV binop .)
    LESS_EQ         reduce using rule 47 (binop -> binop DIV binop .)
    GREATER_EQ      reduce using rule 47 (binop -> binop DIV binop .)
    EQUAL           reduce using rule 47 (binop -> binop DIV binop .)
    NOT_EQUAL       reduce using rule 47 (binop -> binop DIV binop .)
    PLUS            reduce using rule 47 (binop -> binop DIV binop .)
    MINUS           reduce using rule 47 (binop -> binop DIV binop .)
    MUL             reduce using rule 47 (binop -> binop DIV binop .)
    DIV             reduce using rule 47 (binop -> binop DIV binop .)
    SEMICOLON       reduce using rule 47 (binop -> binop DIV binop .)
    NEWLINE         reduce using rule 47 (binop -> binop DIV binop .)
    PAREN_CLOSE     reduce using rule 47 (binop -> binop DIV binop .)
    CURLY_OPEN      reduce using rule 47 (binop -> binop DIV binop .)
    PAREN_OPEN      reduce using rule 47 (binop -> binop DIV binop .)
    IF              reduce using rule 47 (binop -> binop DIV binop .)
    WHILE           reduce using rule 47 (binop -> binop DIV binop .)
    FUNC            reduce using rule 47 (binop -> binop DIV binop .)
    INTEGER         reduce using rule 47 (binop -> binop DIV binop .)
    STRING          reduce using rule 47 (binop -> binop DIV binop .)
    RETURN          reduce using rule 47 (binop -> binop DIV binop .)
    NAME            reduce using rule 47 (binop -> binop DIV binop .)
    VALUE           reduce using rule 47 (binop -> binop DIV binop .)
    $end            reduce using rule 47 (binop -> binop DIV binop .)
    CURLY_CLOSE     reduce using rule 47 (binop -> binop DIV binop .)
    COMMA           reduce using rule 47 (binop -> binop DIV binop .)

  ! LESS            [ shift and go to state 33 ]
  ! GREATER         [ shift and go to state 34 ]
  ! LESS_EQ         [ shift and go to state 35 ]
  ! GREATER_EQ      [ shift and go to state 36 ]
  ! EQUAL           [ shift and go to state 37 ]
  ! NOT_EQUAL       [ shift and go to state 38 ]
  ! PLUS            [ shift and go to state 39 ]
  ! MINUS           [ shift and go to state 40 ]
  ! MUL             [ shift and go to state 41 ]
  ! DIV             [ shift and go to state 42 ]


state 73

    (21) func_call -> id . PAREN_OPEN params PAREN_CLOSE
    (22) func_call -> id . PAREN_OPEN PAREN_CLOSE
    (52) value -> id .

  ! shift/reduce conflict for PAREN_OPEN resolved as shift
    PAREN_OPEN      shift and go to state 52
    LESS            reduce using rule 52 (value -> id .)
    GREATER         reduce using rule 52 (value -> id .)
    LESS_EQ         reduce using rule 52 (value -> id .)
    GREATER_EQ      reduce using rule 52 (value -> id .)
    EQUAL           reduce using rule 52 (value -> id .)
    NOT_EQUAL       reduce using rule 52 (value -> id .)
    PLUS            reduce using rule 52 (value -> id .)
    MINUS           reduce using rule 52 (value -> id .)
    MUL             reduce using rule 52 (value -> id .)
    DIV             reduce using rule 52 (value -> id .)
    SEMICOLON       reduce using rule 52 (value -> id .)
    NEWLINE         reduce using rule 52 (value -> id .)
    IF              reduce using rule 52 (value -> id .)
    WHILE           reduce using rule 52 (value -> id .)
    FUNC            reduce using rule 52 (value -> id .)
    INTEGER         reduce using rule 52 (value -> id .)
    STRING          reduce using rule 52 (value -> id .)
    RETURN          reduce using rule 52 (value -> id .)
    NAME            reduce using rule 52 (value -> id .)
    VALUE           reduce using rule 52 (value -> id .)
    $end            reduce using rule 52 (value -> id .)
    CURLY_CLOSE     reduce using rule 52 (value -> id .)
    PAREN_CLOSE     reduce using rule 52 (value -> id .)
    COMMA           reduce using rule 52 (value -> id .)

  ! PAREN_OPEN      [ reduce using rule 52 (value -> id .) ]


state 74

    (23) assign -> id ASSIGN expr .

    SEMICOLON       reduce using rule 23 (assign -> id ASSIGN expr .)
    NEWLINE         reduce using rule 23 (assign -> id ASSIGN expr .)
    PAREN_OPEN      reduce using rule 23 (assign -> id ASSIGN expr .)
    IF              reduce using rule 23 (assign -> id ASSIGN expr .)
    WHILE           reduce using rule 23 (assign -> id ASSIGN expr .)
    FUNC            reduce using rule 23 (assign -> id ASSIGN expr .)
    MINUS           reduce using rule 23 (assign -> id ASSIGN expr .)
    INTEGER         reduce using rule 23 (assign -> id ASSIGN expr .)
    STRING          reduce using rule 23 (assign -> id ASSIGN expr .)
    RETURN          reduce using rule 23 (assign -> id ASSIGN expr .)
    NAME            reduce using rule 23 (assign -> id ASSIGN expr .)
    VALUE           reduce using rule 23 (assign -> id ASSIGN expr .)
    $end            reduce using rule 23 (assign -> id ASSIGN expr .)
    CURLY_CLOSE     reduce using rule 23 (assign -> id ASSIGN expr .)


state 75

    (33) expr -> binop .
    (37) binop -> binop . LESS binop
    (38) binop -> binop . GREATER binop
    (39) binop -> binop . LESS_EQ binop
    (40) binop -> binop . GREATER_EQ binop
    (41) binop -> binop . EQUAL binop
    (42) binop -> binop . NOT_EQUAL binop
    (44) binop -> binop . PLUS binop
    (45) binop -> binop . MINUS binop
    (46) binop -> binop . MUL binop
    (47) binop -> binop . DIV binop

  ! shift/reduce conflict for MINUS resolved as shift
    SEMICOLON       reduce using rule 33 (expr -> binop .)
    NEWLINE         reduce using rule 33 (expr -> binop .)
    PAREN_OPEN      reduce using rule 33 (expr -> binop .)
    IF              reduce using rule 33 (expr -> binop .)
    WHILE           reduce using rule 33 (expr -> binop .)
    FUNC            reduce using rule 33 (expr -> binop .)
    INTEGER         reduce using rule 33 (expr -> binop .)
    STRING          reduce using rule 33 (expr -> binop .)
    RETURN          reduce using rule 33 (expr -> binop .)
    NAME            reduce using rule 33 (expr -> binop .)
    VALUE           reduce using rule 33 (expr -> binop .)
    $end            reduce using rule 33 (expr -> binop .)
    CURLY_CLOSE     reduce using rule 33 (expr -> binop .)
    PAREN_CLOSE     reduce using rule 33 (expr -> binop .)
    COMMA           reduce using rule 33 (expr -> binop .)
    LESS            shift and go to state 33
    GREATER         shift and go to state 34
    LESS_EQ         shift and go to state 35
    GREATER_EQ      shift and go to state 36
    EQUAL           shift and go to state 37
    NOT_EQUAL       shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MUL             shift and go to state 41
    DIV             shift and go to state 42

  ! MINUS           [ reduce using rule 33 (expr -> binop .) ]


state 76

    (34) expr -> func_call .

    SEMICOLON       reduce using rule 34 (expr -> func_call .)
    NEWLINE         reduce using rule 34 (expr -> func_call .)
    PAREN_OPEN      reduce using rule 34 (expr -> func_call .)
    IF              reduce using rule 34 (expr -> func_call .)
    WHILE           reduce using rule 34 (expr -> func_call .)
    FUNC            reduce using rule 34 (expr -> func_call .)
    MINUS           reduce using rule 34 (expr -> func_call .)
    INTEGER         reduce using rule 34 (expr -> func_call .)
    STRING          reduce using rule 34 (expr -> func_call .)
    RETURN          reduce using rule 34 (expr -> func_call .)
    NAME            reduce using rule 34 (expr -> func_call .)
    VALUE           reduce using rule 34 (expr -> func_call .)
    $end            reduce using rule 34 (expr -> func_call .)
    CURLY_CLOSE     reduce using rule 34 (expr -> func_call .)
    PAREN_CLOSE     reduce using rule 34 (expr -> func_call .)
    COMMA           reduce using rule 34 (expr -> func_call .)


state 77

    (35) expr -> new .

    SEMICOLON       reduce using rule 35 (expr -> new .)
    NEWLINE         reduce using rule 35 (expr -> new .)
    PAREN_OPEN      reduce using rule 35 (expr -> new .)
    IF              reduce using rule 35 (expr -> new .)
    WHILE           reduce using rule 35 (expr -> new .)
    FUNC            reduce using rule 35 (expr -> new .)
    MINUS           reduce using rule 35 (expr -> new .)
    INTEGER         reduce using rule 35 (expr -> new .)
    STRING          reduce using rule 35 (expr -> new .)
    RETURN          reduce using rule 35 (expr -> new .)
    NAME            reduce using rule 35 (expr -> new .)
    VALUE           reduce using rule 35 (expr -> new .)
    $end            reduce using rule 35 (expr -> new .)
    CURLY_CLOSE     reduce using rule 35 (expr -> new .)
    PAREN_CLOSE     reduce using rule 35 (expr -> new .)
    COMMA           reduce using rule 35 (expr -> new .)


state 78

    (36) new -> NEW . func_call
    (21) func_call -> . id PAREN_OPEN params PAREN_CLOSE
    (22) func_call -> . id PAREN_OPEN PAREN_CLOSE
    (55) id -> . NAME
    (56) id -> . VALUE

    NAME            shift and go to state 26
    VALUE           shift and go to state 27

    func_call                      shift and go to state 91
    id                             shift and go to state 92

state 79

    (21) func_call -> id PAREN_OPEN params . PAREN_CLOSE
    (25) params -> params . COMMA o_newline expr

    PAREN_CLOSE     shift and go to state 93
    COMMA           shift and go to state 94


state 80

    (22) func_call -> id PAREN_OPEN PAREN_CLOSE .

    SEMICOLON       reduce using rule 22 (func_call -> id PAREN_OPEN PAREN_CLOSE .)
    NEWLINE         reduce using rule 22 (func_call -> id PAREN_OPEN PAREN_CLOSE .)
    PAREN_OPEN      reduce using rule 22 (func_call -> id PAREN_OPEN PAREN_CLOSE .)
    IF              reduce using rule 22 (func_call -> id PAREN_OPEN PAREN_CLOSE .)
    WHILE           reduce using rule 22 (func_call -> id PAREN_OPEN PAREN_CLOSE .)
    FUNC            reduce using rule 22 (func_call -> id PAREN_OPEN PAREN_CLOSE .)
    MINUS           reduce using rule 22 (func_call -> id PAREN_OPEN PAREN_CLOSE .)
    INTEGER         reduce using rule 22 (func_call -> id PAREN_OPEN PAREN_CLOSE .)
    STRING          reduce using rule 22 (func_call -> id PAREN_OPEN PAREN_CLOSE .)
    RETURN          reduce using rule 22 (func_call -> id PAREN_OPEN PAREN_CLOSE .)
    NAME            reduce using rule 22 (func_call -> id PAREN_OPEN PAREN_CLOSE .)
    VALUE           reduce using rule 22 (func_call -> id PAREN_OPEN PAREN_CLOSE .)
    $end            reduce using rule 22 (func_call -> id PAREN_OPEN PAREN_CLOSE .)
    CURLY_CLOSE     reduce using rule 22 (func_call -> id PAREN_OPEN PAREN_CLOSE .)
    PAREN_CLOSE     reduce using rule 22 (func_call -> id PAREN_OPEN PAREN_CLOSE .)
    COMMA           reduce using rule 22 (func_call -> id PAREN_OPEN PAREN_CLOSE .)


state 81

    (26) params -> binop .
    (37) binop -> binop . LESS binop
    (38) binop -> binop . GREATER binop
    (39) binop -> binop . LESS_EQ binop
    (40) binop -> binop . GREATER_EQ binop
    (41) binop -> binop . EQUAL binop
    (42) binop -> binop . NOT_EQUAL binop
    (44) binop -> binop . PLUS binop
    (45) binop -> binop . MINUS binop
    (46) binop -> binop . MUL binop
    (47) binop -> binop . DIV binop

    PAREN_CLOSE     reduce using rule 26 (params -> binop .)
    COMMA           reduce using rule 26 (params -> binop .)
    LESS            shift and go to state 33
    GREATER         shift and go to state 34
    LESS_EQ         shift and go to state 35
    GREATER_EQ      shift and go to state 36
    EQUAL           shift and go to state 37
    NOT_EQUAL       shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MUL             shift and go to state 41
    DIV             shift and go to state 42


state 82

    (24) assign -> onetype_args ASSIGN expr .

    SEMICOLON       reduce using rule 24 (assign -> onetype_args ASSIGN expr .)
    NEWLINE         reduce using rule 24 (assign -> onetype_args ASSIGN expr .)
    PAREN_OPEN      reduce using rule 24 (assign -> onetype_args ASSIGN expr .)
    IF              reduce using rule 24 (assign -> onetype_args ASSIGN expr .)
    WHILE           reduce using rule 24 (assign -> onetype_args ASSIGN expr .)
    FUNC            reduce using rule 24 (assign -> onetype_args ASSIGN expr .)
    MINUS           reduce using rule 24 (assign -> onetype_args ASSIGN expr .)
    INTEGER         reduce using rule 24 (assign -> onetype_args ASSIGN expr .)
    STRING          reduce using rule 24 (assign -> onetype_args ASSIGN expr .)
    RETURN          reduce using rule 24 (assign -> onetype_args ASSIGN expr .)
    NAME            reduce using rule 24 (assign -> onetype_args ASSIGN expr .)
    VALUE           reduce using rule 24 (assign -> onetype_args ASSIGN expr .)
    $end            reduce using rule 24 (assign -> onetype_args ASSIGN expr .)
    CURLY_CLOSE     reduce using rule 24 (assign -> onetype_args ASSIGN expr .)


state 83

    (28) onetype_args -> onetype_args COMMA o_newline . id
    (55) id -> . NAME
    (56) id -> . VALUE

    NAME            shift and go to state 26
    VALUE           shift and go to state 27

    id                             shift and go to state 95

state 84

    (57) o_newline -> NEWLINE .

    NAME            reduce using rule 57 (o_newline -> NEWLINE .)
    VALUE           reduce using rule 57 (o_newline -> NEWLINE .)
    PAREN_OPEN      reduce using rule 57 (o_newline -> NEWLINE .)
    IF              reduce using rule 57 (o_newline -> NEWLINE .)
    WHILE           reduce using rule 57 (o_newline -> NEWLINE .)
    FUNC            reduce using rule 57 (o_newline -> NEWLINE .)
    MINUS           reduce using rule 57 (o_newline -> NEWLINE .)
    INTEGER         reduce using rule 57 (o_newline -> NEWLINE .)
    STRING          reduce using rule 57 (o_newline -> NEWLINE .)
    RETURN          reduce using rule 57 (o_newline -> NEWLINE .)
    SEMICOLON       reduce using rule 57 (o_newline -> NEWLINE .)
    NEWLINE         reduce using rule 57 (o_newline -> NEWLINE .)
    CURLY_CLOSE     reduce using rule 57 (o_newline -> NEWLINE .)
    NEW             reduce using rule 57 (o_newline -> NEWLINE .)


state 85

    (58) o_newline -> empty .

    NAME            reduce using rule 58 (o_newline -> empty .)
    VALUE           reduce using rule 58 (o_newline -> empty .)
    PAREN_OPEN      reduce using rule 58 (o_newline -> empty .)
    IF              reduce using rule 58 (o_newline -> empty .)
    WHILE           reduce using rule 58 (o_newline -> empty .)
    FUNC            reduce using rule 58 (o_newline -> empty .)
    MINUS           reduce using rule 58 (o_newline -> empty .)
    INTEGER         reduce using rule 58 (o_newline -> empty .)
    STRING          reduce using rule 58 (o_newline -> empty .)
    RETURN          reduce using rule 58 (o_newline -> empty .)
    SEMICOLON       reduce using rule 58 (o_newline -> empty .)
    NEWLINE         reduce using rule 58 (o_newline -> empty .)
    CURLY_CLOSE     reduce using rule 58 (o_newline -> empty .)
    NEW             reduce using rule 58 (o_newline -> empty .)


state 86

    (48) binop -> PAREN_OPEN binop PAREN_CLOSE .

    LESS            reduce using rule 48 (binop -> PAREN_OPEN binop PAREN_CLOSE .)
    GREATER         reduce using rule 48 (binop -> PAREN_OPEN binop PAREN_CLOSE .)
    LESS_EQ         reduce using rule 48 (binop -> PAREN_OPEN binop PAREN_CLOSE .)
    GREATER_EQ      reduce using rule 48 (binop -> PAREN_OPEN binop PAREN_CLOSE .)
    EQUAL           reduce using rule 48 (binop -> PAREN_OPEN binop PAREN_CLOSE .)
    NOT_EQUAL       reduce using rule 48 (binop -> PAREN_OPEN binop PAREN_CLOSE .)
    PLUS            reduce using rule 48 (binop -> PAREN_OPEN binop PAREN_CLOSE .)
    MINUS           reduce using rule 48 (binop -> PAREN_OPEN binop PAREN_CLOSE .)
    MUL             reduce using rule 48 (binop -> PAREN_OPEN binop PAREN_CLOSE .)
    DIV             reduce using rule 48 (binop -> PAREN_OPEN binop PAREN_CLOSE .)
    SEMICOLON       reduce using rule 48 (binop -> PAREN_OPEN binop PAREN_CLOSE .)
    NEWLINE         reduce using rule 48 (binop -> PAREN_OPEN binop PAREN_CLOSE .)
    PAREN_CLOSE     reduce using rule 48 (binop -> PAREN_OPEN binop PAREN_CLOSE .)
    CURLY_OPEN      reduce using rule 48 (binop -> PAREN_OPEN binop PAREN_CLOSE .)
    PAREN_OPEN      reduce using rule 48 (binop -> PAREN_OPEN binop PAREN_CLOSE .)
    IF              reduce using rule 48 (binop -> PAREN_OPEN binop PAREN_CLOSE .)
    WHILE           reduce using rule 48 (binop -> PAREN_OPEN binop PAREN_CLOSE .)
    FUNC            reduce using rule 48 (binop -> PAREN_OPEN binop PAREN_CLOSE .)
    INTEGER         reduce using rule 48 (binop -> PAREN_OPEN binop PAREN_CLOSE .)
    STRING          reduce using rule 48 (binop -> PAREN_OPEN binop PAREN_CLOSE .)
    RETURN          reduce using rule 48 (binop -> PAREN_OPEN binop PAREN_CLOSE .)
    NAME            reduce using rule 48 (binop -> PAREN_OPEN binop PAREN_CLOSE .)
    VALUE           reduce using rule 48 (binop -> PAREN_OPEN binop PAREN_CLOSE .)
    $end            reduce using rule 48 (binop -> PAREN_OPEN binop PAREN_CLOSE .)
    CURLY_CLOSE     reduce using rule 48 (binop -> PAREN_OPEN binop PAREN_CLOSE .)
    COMMA           reduce using rule 48 (binop -> PAREN_OPEN binop PAREN_CLOSE .)


state 87

    (17) if -> IF binop code_block .
    (18) if -> IF binop code_block . ELSE code_block

    SEMICOLON       reduce using rule 17 (if -> IF binop code_block .)
    NEWLINE         reduce using rule 17 (if -> IF binop code_block .)
    ELSE            shift and go to state 96


state 88

    (20) code_block -> CURLY_OPEN . o_newline program CURLY_CLOSE
    (57) o_newline -> . NEWLINE
    (58) o_newline -> . empty
    (63) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 84
    PAREN_OPEN      reduce using rule 63 (empty -> .)
    IF              reduce using rule 63 (empty -> .)
    WHILE           reduce using rule 63 (empty -> .)
    FUNC            reduce using rule 63 (empty -> .)
    MINUS           reduce using rule 63 (empty -> .)
    INTEGER         reduce using rule 63 (empty -> .)
    STRING          reduce using rule 63 (empty -> .)
    RETURN          reduce using rule 63 (empty -> .)
    SEMICOLON       reduce using rule 63 (empty -> .)
    NAME            reduce using rule 63 (empty -> .)
    VALUE           reduce using rule 63 (empty -> .)
    CURLY_CLOSE     reduce using rule 63 (empty -> .)

  ! NEWLINE         [ reduce using rule 63 (empty -> .) ]

    o_newline                      shift and go to state 97
    empty                          shift and go to state 85

state 89

    (19) while -> WHILE binop code_block .

    SEMICOLON       reduce using rule 19 (while -> WHILE binop code_block .)
    NEWLINE         reduce using rule 19 (while -> WHILE binop code_block .)


state 90

    (16) func -> FUNC id PAREN_OPEN . typeargs PAREN_CLOSE o_id code_block
    (29) typeargs -> . typeargs COMMA o_newline typed_var
    (30) typeargs -> . typeargs COMMA o_newline id
    (31) typeargs -> . typed_var
    (32) typed_var -> . id id
    (55) id -> . NAME
    (56) id -> . VALUE

    NAME            shift and go to state 26
    VALUE           shift and go to state 27

    id                             shift and go to state 98
    typeargs                       shift and go to state 99
    typed_var                      shift and go to state 100

state 91

    (36) new -> NEW func_call .

    SEMICOLON       reduce using rule 36 (new -> NEW func_call .)
    NEWLINE         reduce using rule 36 (new -> NEW func_call .)
    PAREN_OPEN      reduce using rule 36 (new -> NEW func_call .)
    IF              reduce using rule 36 (new -> NEW func_call .)
    WHILE           reduce using rule 36 (new -> NEW func_call .)
    FUNC            reduce using rule 36 (new -> NEW func_call .)
    MINUS           reduce using rule 36 (new -> NEW func_call .)
    INTEGER         reduce using rule 36 (new -> NEW func_call .)
    STRING          reduce using rule 36 (new -> NEW func_call .)
    RETURN          reduce using rule 36 (new -> NEW func_call .)
    NAME            reduce using rule 36 (new -> NEW func_call .)
    VALUE           reduce using rule 36 (new -> NEW func_call .)
    $end            reduce using rule 36 (new -> NEW func_call .)
    CURLY_CLOSE     reduce using rule 36 (new -> NEW func_call .)
    PAREN_CLOSE     reduce using rule 36 (new -> NEW func_call .)
    COMMA           reduce using rule 36 (new -> NEW func_call .)


state 92

    (21) func_call -> id . PAREN_OPEN params PAREN_CLOSE
    (22) func_call -> id . PAREN_OPEN PAREN_CLOSE

    PAREN_OPEN      shift and go to state 52


state 93

    (21) func_call -> id PAREN_OPEN params PAREN_CLOSE .

    SEMICOLON       reduce using rule 21 (func_call -> id PAREN_OPEN params PAREN_CLOSE .)
    NEWLINE         reduce using rule 21 (func_call -> id PAREN_OPEN params PAREN_CLOSE .)
    PAREN_OPEN      reduce using rule 21 (func_call -> id PAREN_OPEN params PAREN_CLOSE .)
    IF              reduce using rule 21 (func_call -> id PAREN_OPEN params PAREN_CLOSE .)
    WHILE           reduce using rule 21 (func_call -> id PAREN_OPEN params PAREN_CLOSE .)
    FUNC            reduce using rule 21 (func_call -> id PAREN_OPEN params PAREN_CLOSE .)
    MINUS           reduce using rule 21 (func_call -> id PAREN_OPEN params PAREN_CLOSE .)
    INTEGER         reduce using rule 21 (func_call -> id PAREN_OPEN params PAREN_CLOSE .)
    STRING          reduce using rule 21 (func_call -> id PAREN_OPEN params PAREN_CLOSE .)
    RETURN          reduce using rule 21 (func_call -> id PAREN_OPEN params PAREN_CLOSE .)
    NAME            reduce using rule 21 (func_call -> id PAREN_OPEN params PAREN_CLOSE .)
    VALUE           reduce using rule 21 (func_call -> id PAREN_OPEN params PAREN_CLOSE .)
    $end            reduce using rule 21 (func_call -> id PAREN_OPEN params PAREN_CLOSE .)
    CURLY_CLOSE     reduce using rule 21 (func_call -> id PAREN_OPEN params PAREN_CLOSE .)
    PAREN_CLOSE     reduce using rule 21 (func_call -> id PAREN_OPEN params PAREN_CLOSE .)
    COMMA           reduce using rule 21 (func_call -> id PAREN_OPEN params PAREN_CLOSE .)


state 94

    (25) params -> params COMMA . o_newline expr
    (57) o_newline -> . NEWLINE
    (58) o_newline -> . empty
    (63) empty -> .

    NEWLINE         shift and go to state 84
    PAREN_OPEN      reduce using rule 63 (empty -> .)
    NEW             reduce using rule 63 (empty -> .)
    MINUS           reduce using rule 63 (empty -> .)
    INTEGER         reduce using rule 63 (empty -> .)
    STRING          reduce using rule 63 (empty -> .)
    NAME            reduce using rule 63 (empty -> .)
    VALUE           reduce using rule 63 (empty -> .)

    o_newline                      shift and go to state 101
    empty                          shift and go to state 85

state 95

    (28) onetype_args -> onetype_args COMMA o_newline id .

    ASSIGN          reduce using rule 28 (onetype_args -> onetype_args COMMA o_newline id .)
    COMMA           reduce using rule 28 (onetype_args -> onetype_args COMMA o_newline id .)


state 96

    (18) if -> IF binop code_block ELSE . code_block
    (20) code_block -> . CURLY_OPEN o_newline program CURLY_CLOSE

    CURLY_OPEN      shift and go to state 88

    code_block                     shift and go to state 102

state 97

    (20) code_block -> CURLY_OPEN o_newline . program CURLY_CLOSE
    (1) program -> . operation
    (2) program -> . program operation
    (3) program -> . empty
    (4) operation -> . assign o_end
    (5) operation -> . binop end
    (6) operation -> . func_call end
    (7) operation -> . if end
    (8) operation -> . while end
    (9) operation -> . func end
    (10) operation -> . value end
    (11) operation -> . return o_end
    (12) operation -> . typed_var end
    (13) operation -> . end
    (63) empty -> .
    (23) assign -> . id ASSIGN expr
    (24) assign -> . onetype_args ASSIGN expr
    (37) binop -> . binop LESS binop
    (38) binop -> . binop GREATER binop
    (39) binop -> . binop LESS_EQ binop
    (40) binop -> . binop GREATER_EQ binop
    (41) binop -> . binop EQUAL binop
    (42) binop -> . binop NOT_EQUAL binop
    (43) binop -> . value
    (44) binop -> . binop PLUS binop
    (45) binop -> . binop MINUS binop
    (46) binop -> . binop MUL binop
    (47) binop -> . binop DIV binop
    (48) binop -> . PAREN_OPEN binop PAREN_CLOSE
    (21) func_call -> . id PAREN_OPEN params PAREN_CLOSE
    (22) func_call -> . id PAREN_OPEN PAREN_CLOSE
    (17) if -> . IF binop code_block
    (18) if -> . IF binop code_block ELSE code_block
    (19) while -> . WHILE binop code_block
    (16) func -> . FUNC id PAREN_OPEN typeargs PAREN_CLOSE o_id code_block
    (49) value -> . MINUS value
    (50) value -> . INTEGER
    (51) value -> . STRING
    (52) value -> . id
    (14) return -> . RETURN binop
    (15) return -> . RETURN
    (32) typed_var -> . id id
    (61) end -> . SEMICOLON
    (62) end -> . NEWLINE
    (55) id -> . NAME
    (56) id -> . VALUE
    (27) onetype_args -> . typed_var
    (28) onetype_args -> . onetype_args COMMA o_newline id

  ! shift/reduce conflict for PAREN_OPEN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for NAME resolved as shift
  ! shift/reduce conflict for VALUE resolved as shift
    CURLY_CLOSE     reduce using rule 63 (empty -> .)
    PAREN_OPEN      shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FUNC            shift and go to state 20
    MINUS           shift and go to state 16
    INTEGER         shift and go to state 21
    STRING          shift and go to state 22
    RETURN          shift and go to state 23
    SEMICOLON       shift and go to state 24
    NEWLINE         shift and go to state 25
    NAME            shift and go to state 26
    VALUE           shift and go to state 27

  ! PAREN_OPEN      [ reduce using rule 63 (empty -> .) ]
  ! IF              [ reduce using rule 63 (empty -> .) ]
  ! WHILE           [ reduce using rule 63 (empty -> .) ]
  ! FUNC            [ reduce using rule 63 (empty -> .) ]
  ! MINUS           [ reduce using rule 63 (empty -> .) ]
  ! INTEGER         [ reduce using rule 63 (empty -> .) ]
  ! STRING          [ reduce using rule 63 (empty -> .) ]
  ! RETURN          [ reduce using rule 63 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 63 (empty -> .) ]
  ! NEWLINE         [ reduce using rule 63 (empty -> .) ]
  ! NAME            [ reduce using rule 63 (empty -> .) ]
  ! VALUE           [ reduce using rule 63 (empty -> .) ]

    program                        shift and go to state 103
    operation                      shift and go to state 2
    empty                          shift and go to state 3
    assign                         shift and go to state 4
    binop                          shift and go to state 5
    end                            shift and go to state 6
    func_call                      shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    func                           shift and go to state 10
    value                          shift and go to state 11
    return                         shift and go to state 12
    typed_var                      shift and go to state 13
    id                             shift and go to state 14
    onetype_args                   shift and go to state 15

state 98

    (32) typed_var -> id . id
    (55) id -> . NAME
    (56) id -> . VALUE

    NAME            shift and go to state 26
    VALUE           shift and go to state 27

    id                             shift and go to state 50

state 99

    (16) func -> FUNC id PAREN_OPEN typeargs . PAREN_CLOSE o_id code_block
    (29) typeargs -> typeargs . COMMA o_newline typed_var
    (30) typeargs -> typeargs . COMMA o_newline id

    PAREN_CLOSE     shift and go to state 104
    COMMA           shift and go to state 105


state 100

    (31) typeargs -> typed_var .

    PAREN_CLOSE     reduce using rule 31 (typeargs -> typed_var .)
    COMMA           reduce using rule 31 (typeargs -> typed_var .)


state 101

    (25) params -> params COMMA o_newline . expr
    (33) expr -> . binop
    (34) expr -> . func_call
    (35) expr -> . new
    (37) binop -> . binop LESS binop
    (38) binop -> . binop GREATER binop
    (39) binop -> . binop LESS_EQ binop
    (40) binop -> . binop GREATER_EQ binop
    (41) binop -> . binop EQUAL binop
    (42) binop -> . binop NOT_EQUAL binop
    (43) binop -> . value
    (44) binop -> . binop PLUS binop
    (45) binop -> . binop MINUS binop
    (46) binop -> . binop MUL binop
    (47) binop -> . binop DIV binop
    (48) binop -> . PAREN_OPEN binop PAREN_CLOSE
    (21) func_call -> . id PAREN_OPEN params PAREN_CLOSE
    (22) func_call -> . id PAREN_OPEN PAREN_CLOSE
    (36) new -> . NEW func_call
    (49) value -> . MINUS value
    (50) value -> . INTEGER
    (51) value -> . STRING
    (52) value -> . id
    (55) id -> . NAME
    (56) id -> . VALUE

    PAREN_OPEN      shift and go to state 17
    NEW             shift and go to state 78
    MINUS           shift and go to state 16
    INTEGER         shift and go to state 21
    STRING          shift and go to state 22
    NAME            shift and go to state 26
    VALUE           shift and go to state 27

    expr                           shift and go to state 106
    binop                          shift and go to state 75
    func_call                      shift and go to state 76
    new                            shift and go to state 77
    value                          shift and go to state 58
    id                             shift and go to state 73

state 102

    (18) if -> IF binop code_block ELSE code_block .

    SEMICOLON       reduce using rule 18 (if -> IF binop code_block ELSE code_block .)
    NEWLINE         reduce using rule 18 (if -> IF binop code_block ELSE code_block .)


state 103

    (20) code_block -> CURLY_OPEN o_newline program . CURLY_CLOSE
    (2) program -> program . operation
    (4) operation -> . assign o_end
    (5) operation -> . binop end
    (6) operation -> . func_call end
    (7) operation -> . if end
    (8) operation -> . while end
    (9) operation -> . func end
    (10) operation -> . value end
    (11) operation -> . return o_end
    (12) operation -> . typed_var end
    (13) operation -> . end
    (23) assign -> . id ASSIGN expr
    (24) assign -> . onetype_args ASSIGN expr
    (37) binop -> . binop LESS binop
    (38) binop -> . binop GREATER binop
    (39) binop -> . binop LESS_EQ binop
    (40) binop -> . binop GREATER_EQ binop
    (41) binop -> . binop EQUAL binop
    (42) binop -> . binop NOT_EQUAL binop
    (43) binop -> . value
    (44) binop -> . binop PLUS binop
    (45) binop -> . binop MINUS binop
    (46) binop -> . binop MUL binop
    (47) binop -> . binop DIV binop
    (48) binop -> . PAREN_OPEN binop PAREN_CLOSE
    (21) func_call -> . id PAREN_OPEN params PAREN_CLOSE
    (22) func_call -> . id PAREN_OPEN PAREN_CLOSE
    (17) if -> . IF binop code_block
    (18) if -> . IF binop code_block ELSE code_block
    (19) while -> . WHILE binop code_block
    (16) func -> . FUNC id PAREN_OPEN typeargs PAREN_CLOSE o_id code_block
    (49) value -> . MINUS value
    (50) value -> . INTEGER
    (51) value -> . STRING
    (52) value -> . id
    (14) return -> . RETURN binop
    (15) return -> . RETURN
    (32) typed_var -> . id id
    (61) end -> . SEMICOLON
    (62) end -> . NEWLINE
    (55) id -> . NAME
    (56) id -> . VALUE
    (27) onetype_args -> . typed_var
    (28) onetype_args -> . onetype_args COMMA o_newline id

    CURLY_CLOSE     shift and go to state 107
    PAREN_OPEN      shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FUNC            shift and go to state 20
    MINUS           shift and go to state 16
    INTEGER         shift and go to state 21
    STRING          shift and go to state 22
    RETURN          shift and go to state 23
    SEMICOLON       shift and go to state 24
    NEWLINE         shift and go to state 25
    NAME            shift and go to state 26
    VALUE           shift and go to state 27

    operation                      shift and go to state 28
    assign                         shift and go to state 4
    binop                          shift and go to state 5
    end                            shift and go to state 6
    func_call                      shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    func                           shift and go to state 10
    value                          shift and go to state 11
    return                         shift and go to state 12
    typed_var                      shift and go to state 13
    id                             shift and go to state 14
    onetype_args                   shift and go to state 15

state 104

    (16) func -> FUNC id PAREN_OPEN typeargs PAREN_CLOSE . o_id code_block
    (53) o_id -> . id
    (54) o_id -> . empty
    (55) id -> . NAME
    (56) id -> . VALUE
    (63) empty -> .

    NAME            shift and go to state 26
    VALUE           shift and go to state 27
    CURLY_OPEN      reduce using rule 63 (empty -> .)

    id                             shift and go to state 108
    o_id                           shift and go to state 109
    empty                          shift and go to state 110

state 105

    (29) typeargs -> typeargs COMMA . o_newline typed_var
    (30) typeargs -> typeargs COMMA . o_newline id
    (57) o_newline -> . NEWLINE
    (58) o_newline -> . empty
    (63) empty -> .

    NEWLINE         shift and go to state 84
    NAME            reduce using rule 63 (empty -> .)
    VALUE           reduce using rule 63 (empty -> .)

    o_newline                      shift and go to state 111
    empty                          shift and go to state 85

state 106

    (25) params -> params COMMA o_newline expr .

    PAREN_CLOSE     reduce using rule 25 (params -> params COMMA o_newline expr .)
    COMMA           reduce using rule 25 (params -> params COMMA o_newline expr .)


state 107

    (20) code_block -> CURLY_OPEN o_newline program CURLY_CLOSE .

    ELSE            reduce using rule 20 (code_block -> CURLY_OPEN o_newline program CURLY_CLOSE .)
    SEMICOLON       reduce using rule 20 (code_block -> CURLY_OPEN o_newline program CURLY_CLOSE .)
    NEWLINE         reduce using rule 20 (code_block -> CURLY_OPEN o_newline program CURLY_CLOSE .)


state 108

    (53) o_id -> id .

    CURLY_OPEN      reduce using rule 53 (o_id -> id .)


state 109

    (16) func -> FUNC id PAREN_OPEN typeargs PAREN_CLOSE o_id . code_block
    (20) code_block -> . CURLY_OPEN o_newline program CURLY_CLOSE

    CURLY_OPEN      shift and go to state 88

    code_block                     shift and go to state 112

state 110

    (54) o_id -> empty .

    CURLY_OPEN      reduce using rule 54 (o_id -> empty .)


state 111

    (29) typeargs -> typeargs COMMA o_newline . typed_var
    (30) typeargs -> typeargs COMMA o_newline . id
    (32) typed_var -> . id id
    (55) id -> . NAME
    (56) id -> . VALUE

    NAME            shift and go to state 26
    VALUE           shift and go to state 27

    typed_var                      shift and go to state 113
    id                             shift and go to state 114

state 112

    (16) func -> FUNC id PAREN_OPEN typeargs PAREN_CLOSE o_id code_block .

    SEMICOLON       reduce using rule 16 (func -> FUNC id PAREN_OPEN typeargs PAREN_CLOSE o_id code_block .)
    NEWLINE         reduce using rule 16 (func -> FUNC id PAREN_OPEN typeargs PAREN_CLOSE o_id code_block .)


state 113

    (29) typeargs -> typeargs COMMA o_newline typed_var .

    PAREN_CLOSE     reduce using rule 29 (typeargs -> typeargs COMMA o_newline typed_var .)
    COMMA           reduce using rule 29 (typeargs -> typeargs COMMA o_newline typed_var .)


state 114

    (30) typeargs -> typeargs COMMA o_newline id .
    (32) typed_var -> id . id
    (55) id -> . NAME
    (56) id -> . VALUE

    PAREN_CLOSE     reduce using rule 30 (typeargs -> typeargs COMMA o_newline id .)
    COMMA           reduce using rule 30 (typeargs -> typeargs COMMA o_newline id .)
    NAME            shift and go to state 26
    VALUE           shift and go to state 27

    id                             shift and go to state 50
WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PAREN_OPEN in state 0 resolved as shift
WARNING: shift/reduce conflict for IF in state 0 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 0 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 0 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 0 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 0 resolved as shift
WARNING: shift/reduce conflict for STRING in state 0 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 0 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 0 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 0 resolved as shift
WARNING: shift/reduce conflict for NAME in state 0 resolved as shift
WARNING: shift/reduce conflict for VALUE in state 0 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 4 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 4 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 11 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 11 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 12 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 12 resolved as shift
WARNING: shift/reduce conflict for PAREN_OPEN in state 23 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 23 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 23 resolved as shift
WARNING: shift/reduce conflict for STRING in state 23 resolved as shift
WARNING: shift/reduce conflict for NAME in state 23 resolved as shift
WARNING: shift/reduce conflict for VALUE in state 23 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 62 resolved as shift
WARNING: shift/reduce conflict for PAREN_OPEN in state 73 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 75 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 88 resolved as shift
WARNING: shift/reduce conflict for PAREN_OPEN in state 97 resolved as shift
WARNING: shift/reduce conflict for IF in state 97 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 97 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 97 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 97 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 97 resolved as shift
WARNING: shift/reduce conflict for STRING in state 97 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 97 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 97 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 97 resolved as shift
WARNING: shift/reduce conflict for NAME in state 97 resolved as shift
WARNING: shift/reduce conflict for VALUE in state 97 resolved as shift
